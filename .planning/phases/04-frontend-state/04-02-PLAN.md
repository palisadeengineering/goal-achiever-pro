---
phase: 04-frontend-state
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/lib/hooks/use-goal-tree.ts
  - src/lib/hooks/use-kpi-mutations.ts
  - src/lib/hooks/query-keys.ts
autonomous: true

must_haves:
  truths:
    - "Query keys follow hierarchical pattern: ['goalTree', visionId] and ['goalTree', visionId, 'kpi', kpiId]"
    - "Invalidating ['goalTree', visionId] invalidates all KPI queries under that vision"
    - "Loading states clearly indicate when progress is being recalculated"
    - "Cache is updated with server response data after mutation settles"
  artifacts:
    - path: "src/lib/hooks/query-keys.ts"
      provides: "Centralized query key factory"
      exports: ["goalTreeKeys"]
    - path: "src/lib/hooks/use-goal-tree.ts"
      provides: "Enhanced hook using query key factory"
      contains: "goalTreeKeys"
    - path: "src/lib/hooks/use-kpi-mutations.ts"
      provides: "Enhanced mutations with targeted invalidation"
      contains: "goalTreeKeys"
  key_links:
    - from: "src/lib/hooks/use-kpi-mutations.ts"
      to: "src/lib/hooks/query-keys.ts"
      via: "import goalTreeKeys"
      pattern: "goalTreeKeys\\."
    - from: "src/lib/hooks/use-goal-tree.ts"
      to: "src/lib/hooks/query-keys.ts"
      via: "import goalTreeKeys"
      pattern: "goalTreeKeys\\."
---

<objective>
Implement hierarchical query key structure and targeted cache invalidation for efficient tree updates.

Purpose: Enable precise cache updates when KPIs change, avoiding full tree refetches while maintaining consistency across the hierarchy.

Output: Query key factory and enhanced hooks with loading state indicators.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Previous plan output
@.planning/phases/04-frontend-state/04-01-SUMMARY.md

# Types for query responses
@src/lib/progress/tree.ts
@src/lib/progress/ancestor-rollup.ts

# Existing hooks to enhance
@src/lib/hooks/use-goal-tree.ts
@src/lib/hooks/use-kpi-mutations.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create query key factory</name>
  <files>src/lib/hooks/query-keys.ts</files>
  <action>
Create a centralized query key factory for goal tree queries following TanStack Query best practices.

The factory must provide hierarchical keys that enable targeted invalidation:

```typescript
/**
 * Query Key Factory for Goal Tree
 *
 * Hierarchical structure enables targeted invalidation:
 * - goalTreeKeys.all -> invalidates everything
 * - goalTreeKeys.trees() -> invalidates all trees
 * - goalTreeKeys.tree(visionId) -> invalidates specific vision's tree
 * - goalTreeKeys.kpis(visionId) -> invalidates all KPIs under a vision
 * - goalTreeKeys.kpi(visionId, kpiId) -> invalidates specific KPI
 */
export const goalTreeKeys = {
  all: ['goalTree'] as const,

  trees: () => [...goalTreeKeys.all, 'tree'] as const,
  tree: (visionId: string) => [...goalTreeKeys.trees(), visionId] as const,

  kpis: (visionId: string) => [...goalTreeKeys.tree(visionId), 'kpi'] as const,
  kpi: (visionId: string, kpiId: string) => [...goalTreeKeys.kpis(visionId), kpiId] as const,

  logs: (visionId: string, kpiId: string) => [...goalTreeKeys.kpi(visionId, kpiId), 'logs'] as const,

  // For invalidation - returns key pattern
  invalidateTree: (visionId: string) => goalTreeKeys.tree(visionId),
  invalidateAllTrees: () => goalTreeKeys.trees(),
};

// Type helper for query key inference
export type GoalTreeKeys = typeof goalTreeKeys;
```

This pattern follows the "query key factory" pattern from TanStack Query docs.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
File exports factory: `grep "goalTreeKeys" src/lib/hooks/query-keys.ts`
  </verify>
  <done>
Query key factory exported with hierarchical key structure enabling targeted invalidation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update hooks to use query key factory and add loading states</name>
  <files>src/lib/hooks/use-goal-tree.ts, src/lib/hooks/use-kpi-mutations.ts</files>
  <action>
Update both hooks to use the centralized query key factory and enhance loading state handling.

In use-goal-tree.ts:
1. Import goalTreeKeys from './query-keys'
2. Replace hardcoded query key with: goalTreeKeys.tree(visionId)
3. Add isRefetching indicator to return value for loading state clarity
4. Export query key getter for external use

Enhanced return type:
```typescript
interface UseGoalTreeReturn {
  data: GoalTreeResponse | undefined;
  isLoading: boolean;       // Initial load
  isRefetching: boolean;    // Background refetch
  isUpdating: boolean;      // Alias for isRefetching (semantic clarity)
  error: Error | null;
  refetch: () => void;
}
```

In use-kpi-mutations.ts:
1. Import goalTreeKeys from './query-keys'
2. Update onMutate to use factory keys for cache operations
3. Update onSettled to use factory keys for targeted invalidation
4. Add mutation state helpers:
   - isLoggingKpi: boolean (isPending)
   - isRollingBack: boolean (track in state if optimistic update was reversed)

Enhanced cache update in onSettled:
```typescript
onSettled: (data, error, variables, context) => {
  if (data && !error) {
    // Update cache with server response (more accurate than optimistic)
    queryClient.setQueryData(
      goalTreeKeys.tree(visionId),
      (old: GoalTreeResponse | undefined) => {
        if (!old) return old;
        // Apply actual server progress values from rollup.updatedKpis
        return updateTreeWithRollup(old, data.rollup.updatedKpis);
      }
    );
  } else if (error) {
    // Ensure cache is invalidated if rollback failed
    queryClient.invalidateQueries({ queryKey: goalTreeKeys.tree(visionId) });
  }
}
```

Create helper function updateTreeWithRollup:
```typescript
function updateTreeWithRollup(
  tree: GoalTreeResponse,
  updates: AncestorProgressUpdate[]
): GoalTreeResponse {
  // Deep clone tree and apply updates to matching KPI nodes
  // Find each KPI by id and update progress, status, childCount
}
```
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Query key factory used: `grep -l "goalTreeKeys" src/lib/hooks/use-goal-tree.ts src/lib/hooks/use-kpi-mutations.ts`
  </verify>
  <done>
Both hooks use centralized query keys. Loading states clearly indicate recalculation. Cache updates use targeted invalidation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update barrel export with query keys</name>
  <files>src/lib/hooks/index.ts</files>
  <action>
Add query key factory to barrel export.

Add:
```typescript
export { goalTreeKeys, type GoalTreeKeys } from './query-keys';
```

This allows consumers to import query keys for external invalidation:
```typescript
import { goalTreeKeys } from '@/lib/hooks';
queryClient.invalidateQueries({ queryKey: goalTreeKeys.tree(visionId) });
```
  </action>
  <verify>
File exports query keys: `grep "goalTreeKeys" src/lib/hooks/index.ts`
  </verify>
  <done>
Barrel exports goalTreeKeys for external use.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. Query key factory exists with hierarchical keys
3. Both hooks import and use goalTreeKeys
4. Hooks return loading state indicators (isLoading, isRefetching/isUpdating)
5. Mutations use targeted cache invalidation via factory keys
</verification>

<success_criteria>
1. Query keys follow hierarchical pattern enabling partial invalidation
2. Invalidating ['goalTree', visionId] invalidates all related queries
3. Loading states (isLoading, isRefetching) available from hooks
4. Cache updates with server response data after mutation settles
5. All files compile with TypeScript
</success_criteria>

<output>
After completion, create `.planning/phases/04-frontend-state/04-02-SUMMARY.md`
</output>
