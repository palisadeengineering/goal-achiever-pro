---
phase: 02-progress-calculation
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/app/api/vision-kpis/[id]/override/route.ts
  - src/app/api/vision-kpis/[id]/progress/route.ts
  - src/lib/progress/index.ts
autonomous: true

must_haves:
  truths:
    - "User can manually override calculated progress with explanation that persists"
    - "Manual override is protected from automatic recalculation"
    - "User can clear manual override to restore automatic calculation"
    - "Progress library has clean barrel export"
  artifacts:
    - path: "src/app/api/vision-kpis/[id]/override/route.ts"
      provides: "Manual override API endpoint"
      exports: ["POST", "DELETE"]
    - path: "src/lib/progress/index.ts"
      provides: "Barrel export for progress library"
      exports: ["calculateWeightedProgress", "buildProgressFormula", "calculateKpiProgress"]
  key_links:
    - from: "src/app/api/vision-kpis/[id]/override/route.ts"
      to: "src/lib/progress/rollup.ts"
      via: "import for parent recalculation"
      pattern: "import.*from.*progress"
---

<objective>
Implement manual override protection for progress calculations, enabling users to set progress values with explanations that persist through automatic recalculations.

Purpose: This completes PROG-04 (manual override with explanation) and adds the barrel export for clean imports.

Output: Manual override endpoint and progress library barrel export.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-progress-calculation/02-RESEARCH.md
@.planning/phases/02-progress-calculation/02-01-SUMMARY.md
@src/lib/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create manual override endpoint</name>
  <files>src/app/api/vision-kpis/[id]/override/route.ts</files>
  <action>
Create endpoint for manual progress override (PROG-04):

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { calculateKpiProgress, buildCacheUpdateData } from '@/lib/progress/rollup';
import type { WeightedKPI } from '@/lib/progress/types';

const DEMO_USER_ID = '00000000-0000-0000-0000-000000000001';

async function getUserId(supabase: Awaited<ReturnType<typeof createClient>>) {
  if (!supabase) return DEMO_USER_ID;
  const { data: { user } } = await supabase.auth.getUser();
  return user?.id || DEMO_USER_ID;
}

// POST /api/vision-kpis/[id]/override - Set manual override
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: kpiId } = await params;
    const supabase = await createClient();
    if (!supabase) {
      return NextResponse.json({ error: 'Database connection failed' }, { status: 500 });
    }

    const userId = await getUserId(supabase);
    const body = await request.json();
    const { progressPercentage, reason } = body;

    // Validate inputs
    if (progressPercentage === undefined || progressPercentage < 0 || progressPercentage > 100) {
      return NextResponse.json(
        { error: 'progressPercentage must be between 0 and 100' },
        { status: 400 }
      );
    }

    if (!reason || reason.trim().length === 0) {
      return NextResponse.json(
        { error: 'Reason is required for manual override' },
        { status: 400 }
      );
    }

    // Verify KPI belongs to user
    const { data: kpi, error: kpiError } = await supabase
      .from('vision_kpis')
      .select('id, parent_kpi_id, title')
      .eq('id', kpiId)
      .eq('user_id', userId)
      .single();

    if (kpiError || !kpi) {
      return NextResponse.json({ error: 'KPI not found' }, { status: 404 });
    }

    // Get what auto-calculation would produce for transparency
    const { data: children } = await supabase
      .from('vision_kpis')
      .select(`
        id,
        title,
        weight,
        kpi_progress_cache (progress_percentage)
      `)
      .eq('parent_kpi_id', kpiId)
      .eq('is_active', true);

    const weightedChildren: WeightedKPI[] = (children || []).map(c => ({
      id: c.id,
      title: c.title,
      progress: Number(c.kpi_progress_cache?.progress_percentage) || 0,
      weight: Number(c.weight) || 1,
    }));

    const autoCalcResult = calculateKpiProgress(kpiId, weightedChildren);

    // Determine status based on override percentage
    let status: 'not_started' | 'in_progress' | 'at_risk' | 'on_track' | 'completed' = 'in_progress';
    if (progressPercentage >= 100) status = 'completed';
    else if (progressPercentage === 0) status = 'not_started';
    else if (progressPercentage >= 70) status = 'on_track';
    else if (progressPercentage < 30) status = 'at_risk';

    // Update cache with manual override
    const { error: updateError } = await supabase
      .from('kpi_progress_cache')
      .upsert({
        kpi_id: kpiId,
        progress_percentage: progressPercentage.toFixed(2),
        weighted_progress: autoCalcResult.weightedProgress.toFixed(2), // Store what auto-calc would be
        child_count: autoCalcResult.childCount,
        completed_child_count: autoCalcResult.completedChildCount,
        total_weight: autoCalcResult.totalWeight.toFixed(2),
        status,
        calculation_method: 'manual_override',
        manual_override_reason: reason.trim(),
        last_calculated_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      }, { onConflict: 'kpi_id' });

    if (updateError) {
      console.error('Error setting override:', updateError);
      return NextResponse.json({ error: 'Failed to set override' }, { status: 500 });
    }

    // Recalculate parent if exists (parent is NOT protected by this KPI's override)
    if (kpi.parent_kpi_id) {
      await recalculateParent(supabase, kpi.parent_kpi_id);
    }

    return NextResponse.json({
      success: true,
      override: {
        kpiId,
        progressPercentage,
        reason: reason.trim(),
        autoCalculatedWouldBe: autoCalcResult.progressPercentage,
      },
    });
  } catch (error) {
    console.error('Set override error:', error);
    return NextResponse.json({ error: 'Failed to set override' }, { status: 500 });
  }
}

// DELETE /api/vision-kpis/[id]/override - Clear manual override
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: kpiId } = await params;
    const supabase = await createClient();
    if (!supabase) {
      return NextResponse.json({ error: 'Database connection failed' }, { status: 500 });
    }

    const userId = await getUserId(supabase);

    // Verify KPI belongs to user
    const { data: kpi, error: kpiError } = await supabase
      .from('vision_kpis')
      .select('id, parent_kpi_id')
      .eq('id', kpiId)
      .eq('user_id', userId)
      .single();

    if (kpiError || !kpi) {
      return NextResponse.json({ error: 'KPI not found' }, { status: 404 });
    }

    // Recalculate this KPI using auto calculation
    const { data: children } = await supabase
      .from('vision_kpis')
      .select(`
        id,
        title,
        weight,
        kpi_progress_cache (progress_percentage)
      `)
      .eq('parent_kpi_id', kpiId)
      .eq('is_active', true);

    const weightedChildren: WeightedKPI[] = (children || []).map(c => ({
      id: c.id,
      title: c.title,
      progress: Number(c.kpi_progress_cache?.progress_percentage) || 0,
      weight: Number(c.weight) || 1,
    }));

    const result = calculateKpiProgress(kpiId, weightedChildren);
    const cacheData = buildCacheUpdateData(result);

    // Update cache, clearing override
    const { error: updateError } = await supabase
      .from('kpi_progress_cache')
      .upsert({
        kpi_id: kpiId,
        ...cacheData,
        calculation_method: 'auto',
        manual_override_reason: null,
      }, { onConflict: 'kpi_id' });

    if (updateError) {
      console.error('Error clearing override:', updateError);
      return NextResponse.json({ error: 'Failed to clear override' }, { status: 500 });
    }

    // Recalculate parent if exists
    if (kpi.parent_kpi_id) {
      await recalculateParent(supabase, kpi.parent_kpi_id);
    }

    return NextResponse.json({
      success: true,
      newProgress: result.progressPercentage,
    });
  } catch (error) {
    console.error('Clear override error:', error);
    return NextResponse.json({ error: 'Failed to clear override' }, { status: 500 });
  }
}

// Helper to recalculate a parent KPI's progress
async function recalculateParent(
  supabase: Awaited<ReturnType<typeof createClient>>,
  parentKpiId: string
) {
  if (!supabase) return;

  try {
    // Check if parent has manual override - if so, don't recalculate
    const { data: parentCache } = await supabase
      .from('kpi_progress_cache')
      .select('calculation_method')
      .eq('kpi_id', parentKpiId)
      .single();

    if (parentCache?.calculation_method === 'manual_override') {
      return; // Parent is protected by its own override
    }

    // Get parent's children
    const { data: children } = await supabase
      .from('vision_kpis')
      .select(`
        id,
        title,
        weight,
        kpi_progress_cache (progress_percentage)
      `)
      .eq('parent_kpi_id', parentKpiId)
      .eq('is_active', true);

    const weightedChildren: WeightedKPI[] = (children || []).map(c => ({
      id: c.id,
      title: c.title,
      progress: Number(c.kpi_progress_cache?.progress_percentage) || 0,
      weight: Number(c.weight) || 1,
    }));

    const result = calculateKpiProgress(parentKpiId, weightedChildren);
    const cacheData = buildCacheUpdateData(result);

    await supabase
      .from('kpi_progress_cache')
      .upsert({
        kpi_id: parentKpiId,
        ...cacheData,
      }, { onConflict: 'kpi_id' });

    // Continue up the chain
    const { data: parent } = await supabase
      .from('vision_kpis')
      .select('parent_kpi_id')
      .eq('id', parentKpiId)
      .single();

    if (parent?.parent_kpi_id) {
      await recalculateParent(supabase, parent.parent_kpi_id);
    }
  } catch (error) {
    console.error('Error recalculating parent:', error);
  }
}
```

Create directory: `src/app/api/vision-kpis/[id]/override/`
  </action>
  <verify>
1. File exists at correct path
2. `npm run build` passes
3. POST requires progressPercentage and reason
4. DELETE clears override and triggers recalculation
  </verify>
  <done>Manual override endpoint allows setting/clearing overrides with reason</done>
</task>

<task type="auto">
  <name>Task 2: Create barrel export for progress library</name>
  <files>src/lib/progress/index.ts</files>
  <action>
Create a clean barrel export for the progress library:

```typescript
/**
 * Progress Calculation Library
 *
 * Provides weighted progress calculation, formula transparency,
 * and hierarchical rollup for the KPI cascade system.
 *
 * Usage:
 *   import { calculateWeightedProgress, buildProgressFormula } from '@/lib/progress';
 */

// Types
export type {
  CalculationMethod,
  WeightedKPI,
  ProgressComponent,
  ProgressFormula,
  ProgressResult,
  KpiAncestor,
} from './types';

// Calculator functions
export {
  calculateWeightedProgress,
  buildProgressFormula,
  deriveStatus,
  countCompletedChildren,
} from './calculator';

// Rollup functions
export {
  getAncestorsCteQuery,
  getChildrenWithProgressQuery,
  calculateKpiProgress,
  buildCacheUpdateData,
} from './rollup';
```

This allows clean imports like:
```typescript
import { calculateWeightedProgress, type ProgressFormula } from '@/lib/progress';
```
  </action>
  <verify>
1. File exists at `src/lib/progress/index.ts`
2. `npm run build` passes
3. Can import from `@/lib/progress` in another file
  </verify>
  <done>Progress library has clean barrel export</done>
</task>

<task type="auto">
  <name>Task 3: Update progress endpoint to handle override protection</name>
  <files>src/app/api/vision-kpis/[id]/progress/route.ts</files>
  <action>
Update the POST handler in the progress endpoint to respect manual overrides.

Find the section in POST handler where cache is updated (the upsert call) and add a check before it:

Add this check before the upsert:
```typescript
    // Check if this KPI has manual override - if so, skip recalculation
    const { data: existingCache } = await supabase
      .from('kpi_progress_cache')
      .select('calculation_method')
      .eq('kpi_id', kpiId)
      .single();

    if (existingCache?.calculation_method === 'manual_override') {
      return NextResponse.json({
        progress: {
          kpiId,
          message: 'KPI has manual override, skipping auto-recalculation',
          manualOverride: true,
        },
        duration: Date.now() - startTime,
        skipped: true,
      });
    }
```

Also add an optional `forceRecalculate` query parameter to allow bypassing override protection when explicitly requested:

Update the POST handler to check for this:
```typescript
    const { searchParams } = new URL(request.url);
    const forceRecalculate = searchParams.get('force') === 'true';
```

And modify the override check:
```typescript
    if (existingCache?.calculation_method === 'manual_override' && !forceRecalculate) {
      // ... return skipped response
    }
```

If force=true, also clear the manual override fields in the upsert.
  </action>
  <verify>
1. `npm run build` passes
2. POST respects manual_override calculation_method
3. POST with ?force=true bypasses override protection
  </verify>
  <done>Progress endpoint respects manual override protection</done>
</task>

</tasks>

<verification>
1. All files exist:
   - `src/app/api/vision-kpis/[id]/override/route.ts`
   - `src/lib/progress/index.ts`
   - `src/app/api/vision-kpis/[id]/progress/route.ts` (updated)
2. `npm run build` passes without errors
3. Override endpoint requires reason parameter
4. Progress endpoint skips recalculation for overridden KPIs
5. Barrel export works: `import { calculateWeightedProgress } from '@/lib/progress'` compiles
</verification>

<success_criteria>
- Manual override can be set with required explanation
- Manual override persists through automatic recalculations
- User can clear override to restore auto-calculation
- Progress library has clean single import path
</success_criteria>

<output>
After completion, create `.planning/phases/02-progress-calculation/02-03-SUMMARY.md`
</output>
