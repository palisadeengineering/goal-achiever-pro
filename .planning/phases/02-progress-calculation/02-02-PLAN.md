---
phase: 02-progress-calculation
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/app/api/vision-kpis/[id]/progress/route.ts
  - src/app/api/vision-kpis/[id]/log/route.ts
  - src/app/api/progress/formula/route.ts
autonomous: true

must_haves:
  truths:
    - "Logging a KPI completion updates all ancestor progress percentages"
    - "Progress formula endpoint returns transparent calculation breakdown"
    - "Progress cache updates within 100ms of KPI log write"
  artifacts:
    - path: "src/app/api/vision-kpis/[id]/progress/route.ts"
      provides: "Progress cache update endpoint"
      exports: ["GET", "POST", "PUT"]
    - path: "src/app/api/progress/formula/route.ts"
      provides: "Formula transparency endpoint"
      exports: ["GET"]
    - path: "src/app/api/vision-kpis/[id]/log/route.ts"
      provides: "Updated KPI logging with progress rollup"
      contains: "rollupProgressToAncestors"
  key_links:
    - from: "src/app/api/vision-kpis/[id]/log/route.ts"
      to: "src/lib/progress/rollup.ts"
      via: "import rollup functions"
      pattern: "import.*from.*progress"
    - from: "src/app/api/vision-kpis/[id]/progress/route.ts"
      to: "src/lib/progress/calculator.ts"
      via: "import calculator"
      pattern: "import.*from.*progress"
---

<objective>
Create API endpoints for progress rollup and integrate with existing KPI logging to automatically update ancestor progress.

Purpose: This implements PROG-01 (auto-update parent), PROG-02 (full chain rollup), PROG-05 (formula endpoint), and PROG-06 (<100ms cache update).

Output: Progress API endpoints that maintain cache consistency on every KPI log write.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-progress-calculation/02-RESEARCH.md
@.planning/phases/02-progress-calculation/02-01-SUMMARY.md
@src/app/api/vision-kpis/[id]/log/route.ts
@src/lib/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create progress cache endpoint</name>
  <files>src/app/api/vision-kpis/[id]/progress/route.ts</files>
  <action>
Create the progress cache API endpoint:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import {
  calculateKpiProgress,
  buildCacheUpdateData,
  getChildrenWithProgressQuery,
  getAncestorsCteQuery,
} from '@/lib/progress/rollup';
import type { WeightedKPI } from '@/lib/progress/types';

const DEMO_USER_ID = '00000000-0000-0000-0000-000000000001';

async function getUserId(supabase: Awaited<ReturnType<typeof createClient>>) {
  if (!supabase) return DEMO_USER_ID;
  const { data: { user } } = await supabase.auth.getUser();
  return user?.id || DEMO_USER_ID;
}

// GET /api/vision-kpis/[id]/progress - Get cached progress
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: kpiId } = await params;
    const supabase = await createClient();
    if (!supabase) {
      return NextResponse.json({ error: 'Database connection failed' }, { status: 500 });
    }

    const userId = await getUserId(supabase);

    // Fetch progress cache entry
    const { data: cache, error } = await supabase
      .from('kpi_progress_cache')
      .select('*')
      .eq('kpi_id', kpiId)
      .single();

    if (error && error.code !== 'PGRST116') {
      console.error('Error fetching progress cache:', error);
      return NextResponse.json({ error: 'Failed to fetch progress' }, { status: 500 });
    }

    // If no cache entry, calculate on demand
    if (!cache) {
      const { data: children } = await supabase.rpc('get_children_with_progress', { parent_id: kpiId });

      const weightedChildren: WeightedKPI[] = (children || []).map((c: Record<string, unknown>) => ({
        id: c.id as string,
        title: c.title as string,
        progress: Number(c.progress) || 0,
        weight: Number(c.weight) || 1,
      }));

      const result = calculateKpiProgress(kpiId, weightedChildren);
      return NextResponse.json({ progress: result, cached: false });
    }

    return NextResponse.json({
      progress: {
        kpiId,
        progressPercentage: Number(cache.progress_percentage),
        childCount: cache.child_count,
        completedChildCount: cache.completed_child_count,
        weightedProgress: Number(cache.weighted_progress),
        totalWeight: Number(cache.total_weight),
        status: cache.status,
        calculationMethod: cache.calculation_method,
        manualOverrideReason: cache.manual_override_reason,
        lastCalculatedAt: cache.last_calculated_at,
      },
      cached: true,
    });
  } catch (error) {
    console.error('Get progress error:', error);
    return NextResponse.json({ error: 'Failed to fetch progress' }, { status: 500 });
  }
}

// POST /api/vision-kpis/[id]/progress - Recalculate and update cache
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const startTime = Date.now();

  try {
    const { id: kpiId } = await params;
    const supabase = await createClient();
    if (!supabase) {
      return NextResponse.json({ error: 'Database connection failed' }, { status: 500 });
    }

    const userId = await getUserId(supabase);

    // Get direct children with their progress
    const { data: children, error: childError } = await supabase
      .from('vision_kpis')
      .select(`
        id,
        title,
        weight,
        kpi_progress_cache (progress_percentage)
      `)
      .eq('parent_kpi_id', kpiId)
      .eq('is_active', true)
      .order('sort_order', { ascending: true });

    if (childError) {
      console.error('Error fetching children:', childError);
      return NextResponse.json({ error: 'Failed to fetch children' }, { status: 500 });
    }

    // Map to WeightedKPI format
    const weightedChildren: WeightedKPI[] = (children || []).map(c => ({
      id: c.id,
      title: c.title,
      progress: Number(c.kpi_progress_cache?.progress_percentage) || 0,
      weight: Number(c.weight) || 1,
    }));

    // Calculate progress
    const result = calculateKpiProgress(kpiId, weightedChildren);
    const cacheData = buildCacheUpdateData(result);

    // Upsert cache entry
    const { error: upsertError } = await supabase
      .from('kpi_progress_cache')
      .upsert({
        kpi_id: kpiId,
        ...cacheData,
      }, {
        onConflict: 'kpi_id',
      });

    if (upsertError) {
      console.error('Error updating cache:', upsertError);
      return NextResponse.json({ error: 'Failed to update cache' }, { status: 500 });
    }

    const duration = Date.now() - startTime;

    return NextResponse.json({
      progress: result,
      duration,
      cached: true,
    });
  } catch (error) {
    console.error('Recalculate progress error:', error);
    return NextResponse.json({ error: 'Failed to recalculate progress' }, { status: 500 });
  }
}

// PUT /api/vision-kpis/[id]/progress - Update weight
export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: kpiId } = await params;
    const supabase = await createClient();
    if (!supabase) {
      return NextResponse.json({ error: 'Database connection failed' }, { status: 500 });
    }

    const userId = await getUserId(supabase);
    const body = await request.json();
    const { weight } = body;

    if (weight === undefined || weight < 0) {
      return NextResponse.json({ error: 'Valid weight is required' }, { status: 400 });
    }

    // Update weight on the KPI
    const { error: updateError } = await supabase
      .from('vision_kpis')
      .update({ weight, updated_at: new Date().toISOString() })
      .eq('id', kpiId)
      .eq('user_id', userId);

    if (updateError) {
      console.error('Error updating weight:', updateError);
      return NextResponse.json({ error: 'Failed to update weight' }, { status: 500 });
    }

    // Recalculate parent's progress since child weight changed
    const { data: kpi } = await supabase
      .from('vision_kpis')
      .select('parent_kpi_id')
      .eq('id', kpiId)
      .single();

    if (kpi?.parent_kpi_id) {
      // Trigger parent recalculation via POST to this endpoint
      const response = await fetch(
        `${request.nextUrl.origin}/api/vision-kpis/${kpi.parent_kpi_id}/progress`,
        { method: 'POST' }
      );
      if (!response.ok) {
        console.warn('Parent progress recalculation failed');
      }
    }

    return NextResponse.json({ success: true, weight });
  } catch (error) {
    console.error('Update weight error:', error);
    return NextResponse.json({ error: 'Failed to update weight' }, { status: 500 });
  }
}
```
  </action>
  <verify>
1. File exists at correct path
2. `npm run build` passes
3. Exports GET, POST, PUT handlers
  </verify>
  <done>Progress endpoint provides cache read, recalculation, and weight updates</done>
</task>

<task type="auto">
  <name>Task 2: Create formula transparency endpoint</name>
  <files>src/app/api/progress/formula/route.ts</files>
  <action>
Create endpoint for transparent formula breakdown (PROG-05):

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { buildProgressFormula } from '@/lib/progress/calculator';
import type { WeightedKPI, ProgressFormula } from '@/lib/progress/types';

const DEMO_USER_ID = '00000000-0000-0000-0000-000000000001';

async function getUserId(supabase: Awaited<ReturnType<typeof createClient>>) {
  if (!supabase) return DEMO_USER_ID;
  const { data: { user } } = await supabase.auth.getUser();
  return user?.id || DEMO_USER_ID;
}

// GET /api/progress/formula?kpiId=xxx - Get formula breakdown
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient();
    if (!supabase) {
      return NextResponse.json({ error: 'Database connection failed' }, { status: 500 });
    }

    const userId = await getUserId(supabase);
    const { searchParams } = new URL(request.url);
    const kpiId = searchParams.get('kpiId');

    if (!kpiId) {
      return NextResponse.json({ error: 'kpiId is required' }, { status: 400 });
    }

    // Get KPI details and its children
    const { data: kpi, error: kpiError } = await supabase
      .from('vision_kpis')
      .select('id, title, level, parent_kpi_id')
      .eq('id', kpiId)
      .single();

    if (kpiError || !kpi) {
      return NextResponse.json({ error: 'KPI not found' }, { status: 404 });
    }

    // Get children with their progress
    const { data: children, error: childError } = await supabase
      .from('vision_kpis')
      .select(`
        id,
        title,
        weight,
        kpi_progress_cache (
          progress_percentage,
          calculation_method,
          manual_override_reason
        )
      `)
      .eq('parent_kpi_id', kpiId)
      .eq('is_active', true)
      .order('sort_order', { ascending: true });

    if (childError) {
      console.error('Error fetching children:', childError);
      return NextResponse.json({ error: 'Failed to fetch children' }, { status: 500 });
    }

    // Get cache entry for override info
    const { data: cache } = await supabase
      .from('kpi_progress_cache')
      .select('calculation_method, manual_override_reason, progress_percentage')
      .eq('kpi_id', kpiId)
      .single();

    const isManualOverride = cache?.calculation_method === 'manual_override';

    // Build WeightedKPI array
    const weightedChildren: WeightedKPI[] = (children || []).map(c => ({
      id: c.id,
      title: c.title,
      progress: Number(c.kpi_progress_cache?.progress_percentage) || 0,
      weight: Number(c.weight) || 1,
    }));

    // Build formula with override info if applicable
    const formula: ProgressFormula = buildProgressFormula(
      weightedChildren,
      isManualOverride
        ? {
            manualOverride: Number(cache.progress_percentage),
            overrideReason: cache.manual_override_reason,
          }
        : undefined
    );

    return NextResponse.json({
      kpiId,
      kpiTitle: kpi.title,
      level: kpi.level,
      parentKpiId: kpi.parent_kpi_id,
      formula,
      children: weightedChildren.map(c => ({
        id: c.id,
        title: c.title,
        progress: c.progress,
        weight: c.weight,
        contributionPercent: formula.components.find(comp => comp.kpiId === c.id)?.contribution || 0,
      })),
    });
  } catch (error) {
    console.error('Get formula error:', error);
    return NextResponse.json({ error: 'Failed to get formula' }, { status: 500 });
  }
}
```

Create directory if needed: `src/app/api/progress/formula/`
  </action>
  <verify>
1. File exists at correct path
2. `npm run build` passes
3. Endpoint returns formula breakdown structure
  </verify>
  <done>Formula endpoint exposes transparent calculation breakdown for UI</done>
</task>

<task type="auto">
  <name>Task 3: Integrate progress rollup into existing KPI log endpoint</name>
  <files>src/app/api/vision-kpis/[id]/log/route.ts</files>
  <action>
Update the existing KPI log endpoint to trigger progress rollup on every log write.

Add these imports at the top:
```typescript
import { calculateKpiProgress, buildCacheUpdateData } from '@/lib/progress/rollup';
import type { WeightedKPI } from '@/lib/progress/types';
```

Add a new helper function after the existing `recalculateStreak` function:
```typescript
/**
 * Roll up progress to all ancestors after a KPI log
 * This implements PROG-01 and PROG-02
 */
async function rollupProgressToAncestors(
  supabase: Awaited<ReturnType<typeof createClient>>,
  kpiId: string
) {
  if (!supabase) return { updatedKpis: [], duration: 0 };

  const startTime = Date.now();
  const updatedKpis: string[] = [];

  try {
    // First, update the logged KPI's own cache based on its direct value/completion
    const { data: kpi } = await supabase
      .from('vision_kpis')
      .select('id, parent_kpi_id, level')
      .eq('id', kpiId)
      .single();

    if (!kpi) return { updatedKpis, duration: Date.now() - startTime };

    // Get most recent log for this KPI to determine its own progress
    const { data: latestLog } = await supabase
      .from('kpi_logs')
      .select('is_completed, value')
      .eq('kpi_id', kpiId)
      .order('log_date', { ascending: false })
      .limit(1)
      .single();

    // For leaf KPIs (daily level typically), progress is 100 if completed, 0 otherwise
    // For KPIs with numeric targets, calculate percentage
    const { data: kpiDetails } = await supabase
      .from('vision_kpis')
      .select('numeric_target')
      .eq('id', kpiId)
      .single();

    let selfProgress = 0;
    if (latestLog?.is_completed) {
      selfProgress = 100;
    } else if (latestLog?.value && kpiDetails?.numeric_target) {
      selfProgress = Math.min(100, (Number(latestLog.value) / Number(kpiDetails.numeric_target)) * 100);
    }

    // Update this KPI's cache entry
    await supabase
      .from('kpi_progress_cache')
      .upsert({
        kpi_id: kpiId,
        progress_percentage: selfProgress.toFixed(2),
        status: selfProgress >= 100 ? 'completed' : selfProgress > 0 ? 'in_progress' : 'not_started',
        last_calculated_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      }, { onConflict: 'kpi_id' });

    updatedKpis.push(kpiId);

    // Now traverse up the tree and update each ancestor
    let currentParentId = kpi.parent_kpi_id;

    while (currentParentId) {
      // Get children of this parent with their progress
      const { data: children } = await supabase
        .from('vision_kpis')
        .select(`
          id,
          title,
          weight,
          kpi_progress_cache (progress_percentage)
        `)
        .eq('parent_kpi_id', currentParentId)
        .eq('is_active', true);

      const weightedChildren: WeightedKPI[] = (children || []).map(c => ({
        id: c.id,
        title: c.title,
        progress: Number(c.kpi_progress_cache?.progress_percentage) || 0,
        weight: Number(c.weight) || 1,
      }));

      // Check if parent has manual override - if so, skip recalculation
      const { data: parentCache } = await supabase
        .from('kpi_progress_cache')
        .select('calculation_method')
        .eq('kpi_id', currentParentId)
        .single();

      if (parentCache?.calculation_method !== 'manual_override') {
        // Calculate and update parent's progress
        const result = calculateKpiProgress(currentParentId, weightedChildren);
        const cacheData = buildCacheUpdateData(result);

        await supabase
          .from('kpi_progress_cache')
          .upsert({
            kpi_id: currentParentId,
            ...cacheData,
          }, { onConflict: 'kpi_id' });

        updatedKpis.push(currentParentId);
      }

      // Move to next ancestor
      const { data: parent } = await supabase
        .from('vision_kpis')
        .select('parent_kpi_id')
        .eq('id', currentParentId)
        .single();

      currentParentId = parent?.parent_kpi_id;
    }

    return {
      updatedKpis,
      duration: Date.now() - startTime,
    };
  } catch (error) {
    console.error('Error in rollupProgressToAncestors:', error);
    return { updatedKpis, duration: Date.now() - startTime, error: String(error) };
  }
}
```

Update the POST handler to call rollup after updating streak. Find the line `await updateStreak(supabase, id, logDate, isCompleted);` and add after it:
```typescript
    // Roll up progress to all ancestors (PROG-01, PROG-02)
    const rollupResult = await rollupProgressToAncestors(supabase, id);

    return NextResponse.json({
      log,
      rollup: {
        updatedKpis: rollupResult.updatedKpis,
        duration: rollupResult.duration,
      },
    });
```

Remove the original `return NextResponse.json({ log });` line that's now replaced.
  </action>
  <verify>
1. `npm run build` passes
2. POST handler imports progress functions
3. POST handler calls rollupProgressToAncestors
4. Response includes rollup metadata
  </verify>
  <done>KPI log writes trigger automatic ancestor progress updates</done>
</task>

</tasks>

<verification>
1. All three endpoint files exist:
   - `src/app/api/vision-kpis/[id]/progress/route.ts`
   - `src/app/api/progress/formula/route.ts`
   - `src/app/api/vision-kpis/[id]/log/route.ts` (updated)
2. `npm run build` passes without errors
3. Log endpoint imports and uses progress rollup functions
4. Formula endpoint returns ProgressFormula structure
</verification>

<success_criteria>
- Logging a KPI completion triggers ancestor progress recalculation
- Formula endpoint provides transparent calculation breakdown
- Progress cache endpoint supports read, recalculate, and weight updates
- Response includes timing info to verify <100ms target (PROG-06)
</success_criteria>

<output>
After completion, create `.planning/phases/02-progress-calculation/02-02-SUMMARY.md`
</output>
