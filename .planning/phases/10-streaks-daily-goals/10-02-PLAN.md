# Plan 10-02: Daily Streak Service and Gamification Dashboard

## Objective

Create a unified daily streak tracking service that updates user_gamification streaks on any completion action. Integrate gamification display (XP, level, streak) into the Today dashboard. Implement success rate metrics API.

## Execution Context

**Phase**: 10 - Streaks & Daily Goals
**Depends on**: Plan 10-01 (MINS API must exist for completions)
**Scope**: ~400 lines across service, API, and UI components

**Reference files**:
- `src/lib/services/gamification.ts` - existing gamification service
- `src/app/api/non-negotiables/streaks/route.ts` - streak calculation pattern
- `src/app/(dashboard)/today/page.tsx` - Today dashboard to enhance
- `src/components/features/kpi/daily-kpi-dashboard.tsx` - streak UI components

## Context

**Current state**:
- Gamification service has streak fields but no automatic calculation
- Streak is calculated per-KPI and per-non-negotiable, not globally
- Today dashboard shows daily actions but no gamification data

**Target state**:
- Global daily streak: consecutive days with ANY completion
- Automatic streak update on completion actions
- Gamification stats visible on Today dashboard
- Success rate API for analytics

## Tasks

### Task 1: Create daily streak calculation service
**File**: `src/lib/services/streaks.ts` (new file)
**Action**: Create centralized streak calculation and update service

```typescript
import { createAdminClient } from '@/lib/supabase/admin';

export interface DailyStreak {
  currentStreak: number;
  longestStreak: number;
  lastActivityDate: string | null;
  isActiveToday: boolean;
}

export interface SuccessRate {
  totalDays: number;
  activeDays: number;
  rate: number; // percentage
  period: 'week' | 'month' | 'quarter' | 'year';
}

/**
 * Calculate daily streak from activity dates
 * A streak continues if user completed at least one action on consecutive days
 */
export function calculateDailyStreak(activityDates: string[]): { current: number; longest: number } {
  if (activityDates.length === 0) return { current: 0, longest: 0 };

  // Sort dates in descending order (most recent first)
  const sortedDates = [...new Set(activityDates)].sort((a, b) =>
    new Date(b).getTime() - new Date(a).getTime()
  );

  const today = new Date();
  today.setHours(0, 0, 0, 0);

  let currentStreak = 0;
  let longestStreak = 0;
  let tempStreak = 1;

  // Check if most recent activity was today or yesterday
  const lastDate = new Date(sortedDates[0]);
  lastDate.setHours(0, 0, 0, 0);
  const daysSinceLastActivity = Math.floor(
    (today.getTime() - lastDate.getTime()) / (1000 * 60 * 60 * 24)
  );

  // Current streak only counts if activity was today or yesterday
  if (daysSinceLastActivity <= 1) {
    currentStreak = 1;
    let expectedDate = new Date(lastDate);

    for (let i = 1; i < sortedDates.length; i++) {
      expectedDate.setDate(expectedDate.getDate() - 1);
      const currentDate = new Date(sortedDates[i]);
      currentDate.setHours(0, 0, 0, 0);

      if (currentDate.getTime() === expectedDate.getTime()) {
        currentStreak++;
      } else {
        break;
      }
    }
  }

  // Calculate longest streak (historical)
  let prevDate: Date | null = null;
  for (const dateStr of sortedDates) {
    const currentDate = new Date(dateStr);
    currentDate.setHours(0, 0, 0, 0);

    if (prevDate === null) {
      tempStreak = 1;
    } else {
      const daysDiff = Math.floor(
        (prevDate.getTime() - currentDate.getTime()) / (1000 * 60 * 60 * 24)
      );
      if (daysDiff === 1) {
        tempStreak++;
      } else {
        longestStreak = Math.max(longestStreak, tempStreak);
        tempStreak = 1;
      }
    }
    prevDate = currentDate;
  }
  longestStreak = Math.max(longestStreak, tempStreak);

  return { current: currentStreak, longest: longestStreak };
}

/**
 * Get all dates where user had any completion activity
 */
export async function getUserActivityDates(userId: string, startDate: string, endDate: string): Promise<string[]> {
  const adminClient = createAdminClient();
  if (!adminClient) return [];

  // Gather activity dates from multiple sources
  const [kpiLogs, minsCompleted, dailyActions, nonNegotiables] = await Promise.all([
    // KPI completions
    adminClient
      .from('kpi_logs')
      .select('log_date')
      .eq('user_id', userId)
      .eq('is_completed', true)
      .gte('log_date', startDate)
      .lte('log_date', endDate),

    // MINS completions
    adminClient
      .from('mins')
      .select('completed_at')
      .eq('user_id', userId)
      .eq('status', 'completed')
      .not('completed_at', 'is', null),

    // Daily actions completed
    adminClient
      .from('daily_actions')
      .select('completed_at, action_date')
      .eq('user_id', userId)
      .eq('status', 'completed'),

    // Non-negotiable completions
    adminClient
      .from('non_negotiable_completions')
      .select('completion_date')
      .eq('user_id', userId)
      .gte('completion_date', startDate)
      .lte('completion_date', endDate),
  ]);

  const dates = new Set<string>();

  // Add KPI log dates
  kpiLogs.data?.forEach((row) => dates.add(row.log_date));

  // Add MINS completion dates
  minsCompleted.data?.forEach((row) => {
    if (row.completed_at) {
      dates.add(new Date(row.completed_at).toISOString().split('T')[0]);
    }
  });

  // Add daily action completion dates
  dailyActions.data?.forEach((row) => {
    const date = row.completed_at
      ? new Date(row.completed_at).toISOString().split('T')[0]
      : row.action_date;
    if (date >= startDate && date <= endDate) {
      dates.add(date);
    }
  });

  // Add non-negotiable completion dates
  nonNegotiables.data?.forEach((row) => dates.add(row.completion_date));

  return Array.from(dates).sort();
}

/**
 * Update user's daily streak in gamification table
 * Call this after any completion action
 */
export async function updateUserDailyStreak(userId: string): Promise<DailyStreak> {
  const adminClient = createAdminClient();
  if (!adminClient) {
    throw new Error('Failed to create admin client');
  }

  // Get activity dates for last 400 days (covers full year + buffer)
  const endDate = new Date().toISOString().split('T')[0];
  const startDate = new Date();
  startDate.setDate(startDate.getDate() - 400);
  const startDateStr = startDate.toISOString().split('T')[0];

  const activityDates = await getUserActivityDates(userId, startDateStr, endDate);
  const { current, longest } = calculateDailyStreak(activityDates);

  const today = endDate;
  const isActiveToday = activityDates.includes(today);

  // Update user_gamification with new streak values
  const { error } = await adminClient
    .from('user_gamification')
    .update({
      current_streak: current,
      longest_streak: Math.max(current, longest),
      last_activity_date: activityDates[activityDates.length - 1] || null,
      updated_at: new Date().toISOString(),
    })
    .eq('user_id', userId);

  if (error) {
    console.error('Failed to update user streak:', error);
  }

  return {
    currentStreak: current,
    longestStreak: Math.max(current, longest),
    lastActivityDate: activityDates[activityDates.length - 1] || null,
    isActiveToday,
  };
}

/**
 * Calculate success rate for a given period
 */
export async function calculateSuccessRate(
  userId: string,
  period: 'week' | 'month' | 'quarter' | 'year'
): Promise<SuccessRate> {
  const endDate = new Date();
  const startDate = new Date();

  switch (period) {
    case 'week':
      startDate.setDate(endDate.getDate() - 7);
      break;
    case 'month':
      startDate.setDate(endDate.getDate() - 30);
      break;
    case 'quarter':
      startDate.setDate(endDate.getDate() - 90);
      break;
    case 'year':
      startDate.setDate(endDate.getDate() - 365);
      break;
  }

  const startDateStr = startDate.toISOString().split('T')[0];
  const endDateStr = endDate.toISOString().split('T')[0];

  const activityDates = await getUserActivityDates(userId, startDateStr, endDateStr);

  // Calculate total days in period
  const totalDays = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));
  const activeDays = activityDates.length;
  const rate = totalDays > 0 ? Math.round((activeDays / totalDays) * 100) : 0;

  return { totalDays, activeDays, rate, period };
}
```

### Task 2: Create success rate API endpoint
**File**: `src/app/api/gamification/success-rate/route.ts` (new file)
**Action**: Create endpoint for success rate metrics

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { calculateSuccessRate, type SuccessRate } from '@/lib/services/streaks';

const DEMO_USER_ID = '00000000-0000-0000-0000-000000000001';

async function getUserId(supabase: Awaited<ReturnType<typeof createClient>>) {
  if (!supabase) return DEMO_USER_ID;
  const { data: { user } } = await supabase.auth.getUser();
  return user?.id || DEMO_USER_ID;
}

export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient();
    if (!supabase) {
      return NextResponse.json({ error: 'Database connection failed' }, { status: 500 });
    }

    const userId = await getUserId(supabase);
    const { searchParams } = new URL(request.url);
    const period = searchParams.get('period') as 'week' | 'month' | 'quarter' | 'year' || 'month';

    const successRate = await calculateSuccessRate(userId, period);

    // Get all periods for comparison
    const [week, month, quarter, year] = await Promise.all([
      calculateSuccessRate(userId, 'week'),
      calculateSuccessRate(userId, 'month'),
      calculateSuccessRate(userId, 'quarter'),
      calculateSuccessRate(userId, 'year'),
    ]);

    return NextResponse.json({
      current: successRate,
      comparison: { week, month, quarter, year },
    });
  } catch (error) {
    console.error('GET /api/gamification/success-rate error:', error);
    return NextResponse.json({ error: 'Failed to calculate success rate' }, { status: 500 });
  }
}
```

### Task 3: Add streak service barrel export
**File**: `src/lib/services/index.ts`
**Action**: Export streak service

```typescript
export * from './gamification';
export * from './streaks';
```

### Task 4: Integrate streak update into completion flows
**File**: `src/app/api/mins/[id]/route.ts`
**Action**: Call updateUserDailyStreak after completion

In the PUT handler, after awarding XP:
```typescript
import { updateUserDailyStreak } from '@/lib/services/streaks';

// After awarding XP for completion
if (isCompleting && !wasAlreadyCompleted) {
  try {
    gamificationResult = await awardXp(userId, 'KPI_COMPLETED');
    // Update daily streak
    await updateUserDailyStreak(userId);
  } catch (xpError) {
    console.error('Failed to award XP:', xpError);
  }
}
```

Also update `/api/vision-kpis/[id]/log/route.ts` to call `updateUserDailyStreak` after KPI completion.

### Task 5: Create gamification dashboard widget
**File**: `src/components/features/gamification/gamification-widget.tsx` (new file)
**Action**: Create reusable gamification stats widget for dashboards

```typescript
'use client';

import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Progress } from '@/components/ui/progress';
import { Badge } from '@/components/ui/badge';
import { Flame, Trophy, Zap, Target, TrendingUp } from 'lucide-react';
import { cn } from '@/lib/utils';
import { useGamificationStats } from '@/lib/hooks/use-gamification';

const LEVEL_THRESHOLDS = [0, 100, 250, 500, 1000, 2000, 3500, 5500, 8000, 11000, 15000];

function getLevelProgress(totalXp: number, currentLevel: number): { progress: number; xpToNext: number } {
  const currentThreshold = LEVEL_THRESHOLDS[currentLevel - 1] || 0;
  const nextThreshold = LEVEL_THRESHOLDS[currentLevel] || currentThreshold + 1000;
  const xpInLevel = totalXp - currentThreshold;
  const xpNeeded = nextThreshold - currentThreshold;
  return {
    progress: Math.round((xpInLevel / xpNeeded) * 100),
    xpToNext: nextThreshold - totalXp,
  };
}

function getStreakBadge(streak: number): { color: string; label: string } {
  if (streak >= 365) return { color: 'bg-gradient-to-r from-yellow-400 to-orange-500', label: 'Legendary' };
  if (streak >= 90) return { color: 'bg-gradient-to-r from-purple-500 to-pink-500', label: 'Master' };
  if (streak >= 30) return { color: 'bg-gradient-to-r from-blue-500 to-cyan-500', label: 'Champion' };
  if (streak >= 14) return { color: 'bg-gradient-to-r from-green-500 to-emerald-500', label: 'Consistent' };
  if (streak >= 7) return { color: 'bg-cyan-500', label: 'On Fire' };
  if (streak >= 3) return { color: 'bg-orange-500', label: 'Building' };
  return { color: 'bg-gray-400', label: 'Starting' };
}

interface GamificationWidgetProps {
  variant?: 'full' | 'compact';
  className?: string;
}

export function GamificationWidget({ variant = 'full', className }: GamificationWidgetProps) {
  const { data: stats, isLoading } = useGamificationStats();

  if (isLoading || !stats) {
    return (
      <Card className={cn('animate-pulse', className)}>
        <CardContent className="pt-6">
          <div className="h-20 bg-muted rounded" />
        </CardContent>
      </Card>
    );
  }

  const { progress, xpToNext } = getLevelProgress(stats.totalXp, stats.currentLevel);
  const streakBadge = getStreakBadge(stats.currentStreak);

  if (variant === 'compact') {
    return (
      <div className={cn('flex items-center gap-4', className)}>
        <div className="flex items-center gap-2">
          <Zap className="h-4 w-4 text-yellow-500" />
          <span className="text-sm font-medium">{stats.totalXp} XP</span>
        </div>
        <div className="flex items-center gap-2">
          <Trophy className="h-4 w-4 text-purple-500" />
          <span className="text-sm font-medium">Lv.{stats.currentLevel}</span>
        </div>
        {stats.currentStreak > 0 && (
          <Badge className={cn('text-white', streakBadge.color)}>
            <Flame className="h-3 w-3 mr-1" />
            {stats.currentStreak}
          </Badge>
        )}
      </div>
    );
  }

  return (
    <Card className={className}>
      <CardHeader className="pb-2">
        <CardTitle className="text-base flex items-center gap-2">
          <Trophy className="h-4 w-4 text-yellow-500" />
          Progress
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        {/* Level & XP */}
        <div>
          <div className="flex items-center justify-between mb-1">
            <span className="text-sm text-muted-foreground">Level {stats.currentLevel}</span>
            <span className="text-sm font-medium">{stats.totalXp} XP</span>
          </div>
          <Progress value={progress} className="h-2" />
          <p className="text-xs text-muted-foreground mt-1">
            {xpToNext} XP to level {stats.currentLevel + 1}
          </p>
        </div>

        {/* Streak */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <div className={cn(
              'h-8 w-8 rounded-full flex items-center justify-center text-white',
              stats.currentStreak > 0 ? streakBadge.color : 'bg-gray-300'
            )}>
              <Flame className="h-4 w-4" />
            </div>
            <div>
              <p className="text-sm font-medium">
                {stats.currentStreak > 0 ? `${stats.currentStreak} day streak` : 'No streak'}
              </p>
              <p className="text-xs text-muted-foreground">
                {stats.currentStreak > 0 ? streakBadge.label : 'Complete a task to start!'}
              </p>
            </div>
          </div>
          {stats.longestStreak > 0 && (
            <div className="text-right">
              <p className="text-xs text-muted-foreground">Best</p>
              <p className="text-sm font-medium">{stats.longestStreak} days</p>
            </div>
          )}
        </div>

        {/* Stats Grid */}
        <div className="grid grid-cols-2 gap-2">
          <div className="p-2 bg-muted/50 rounded-lg text-center">
            <Target className="h-4 w-4 mx-auto mb-1 text-blue-500" />
            <p className="text-lg font-bold">{stats.kpisCompleted}</p>
            <p className="text-xs text-muted-foreground">KPIs Completed</p>
          </div>
          <div className="p-2 bg-muted/50 rounded-lg text-center">
            <TrendingUp className="h-4 w-4 mx-auto mb-1 text-green-500" />
            <p className="text-lg font-bold">{stats.visionsCreated}</p>
            <p className="text-xs text-muted-foreground">Visions Created</p>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
```

### Task 6: Add gamification widget to Today dashboard
**File**: `src/app/(dashboard)/today/page.tsx`
**Action**: Import and render GamificationWidget in dashboard sidebar

Add the widget to the dashboard layout, typically in a sidebar or stats section.

### Task 7: Create useSuccessRate hook
**File**: `src/lib/hooks/use-gamification.ts`
**Action**: Add success rate hook

Add to existing file:
```typescript
export function useSuccessRate(period: 'week' | 'month' | 'quarter' | 'year' = 'month') {
  return useQuery({
    queryKey: ['gamification', 'successRate', period],
    queryFn: async () => {
      const response = await fetch(`/api/gamification/success-rate?period=${period}`);
      if (!response.ok) throw new Error('Failed to fetch success rate');
      return response.json();
    },
    staleTime: 1000 * 60 * 5, // 5 minutes
  });
}
```

## Verification

```bash
# Build check
npm run build

# Test streak calculation:
# 1. Complete a MINS item
# 2. Check /api/gamification/stats - streak should increment
# 3. Check /api/gamification/success-rate - should show activity

# Verify Today dashboard shows gamification widget
```

## Success Criteria

- [ ] Daily streak calculates from all completion sources
- [ ] Streak updates automatically on any completion
- [ ] Success rate API returns accurate metrics
- [ ] GamificationWidget displays on Today dashboard
- [ ] Streak badge shows current streak level
- [ ] Level progress bar is accurate
- [ ] No TypeScript errors
- [ ] Build passes

## Output

- `src/lib/services/streaks.ts` - Streak calculation service
- `src/app/api/gamification/success-rate/route.ts` - Success rate API
- `src/components/features/gamification/gamification-widget.tsx` - Dashboard widget
- Updated `src/lib/services/index.ts` - Barrel export
- Updated `src/lib/hooks/use-gamification.ts` - Success rate hook
- Updated `src/app/(dashboard)/today/page.tsx` - Widget integration
- Updated MINS completion flow with streak update
