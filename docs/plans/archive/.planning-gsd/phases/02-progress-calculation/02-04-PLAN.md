---
phase: 02-progress-calculation
plan: 04
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - src/app/api/vision-kpis/[id]/override/route.ts
autonomous: true

must_haves:
  truths:
    - "User can manually override calculated progress with explanation that persists"
    - "Manual override is protected from automatic recalculation"
    - "User can clear manual override to restore automatic calculation"
  artifacts:
    - path: "src/app/api/vision-kpis/[id]/override/route.ts"
      provides: "Manual override API endpoint"
      exports: ["POST", "DELETE"]
  key_links:
    - from: "src/app/api/vision-kpis/[id]/override/route.ts"
      to: "src/lib/progress/ancestor-rollup.ts"
      via: "import for parent recalculation"
      pattern: "import.*recalculateParentChain.*from"
---

<objective>
Implement manual override endpoint for progress calculations, enabling users to set progress values with explanations that persist through automatic recalculations.

Purpose: This completes PROG-04 (manual override with explanation).

Output: Manual override endpoint with set and clear functionality.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-progress-calculation/02-RESEARCH.md
@.planning/phases/02-progress-calculation/02-01-SUMMARY.md
@.planning/phases/02-progress-calculation/02-02-SUMMARY.md
@src/lib/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create manual override endpoint</name>
  <files>src/app/api/vision-kpis/[id]/override/route.ts</files>
  <action>
Create endpoint for manual progress override (PROG-04):

First create directory: `src/app/api/vision-kpis/[id]/override/`

Then create the route file:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { calculateKpiProgress, buildCacheUpdateData, recalculateParentChain } from '@/lib/progress';
import type { WeightedKPI } from '@/lib/progress';

const DEMO_USER_ID = '00000000-0000-0000-0000-000000000001';

async function getUserId(supabase: Awaited<ReturnType<typeof createClient>>) {
  if (!supabase) return DEMO_USER_ID;
  const { data: { user } } = await supabase.auth.getUser();
  return user?.id || DEMO_USER_ID;
}

// POST /api/vision-kpis/[id]/override - Set manual override
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: kpiId } = await params;
    const supabase = await createClient();
    if (!supabase) {
      return NextResponse.json({ error: 'Database connection failed' }, { status: 500 });
    }

    const userId = await getUserId(supabase);
    const body = await request.json();
    const { progressPercentage, reason } = body;

    // Validate inputs
    if (progressPercentage === undefined || progressPercentage < 0 || progressPercentage > 100) {
      return NextResponse.json(
        { error: 'progressPercentage must be between 0 and 100' },
        { status: 400 }
      );
    }

    if (!reason || reason.trim().length === 0) {
      return NextResponse.json(
        { error: 'Reason is required for manual override' },
        { status: 400 }
      );
    }

    // Verify KPI belongs to user
    const { data: kpi, error: kpiError } = await supabase
      .from('vision_kpis')
      .select('id, parent_kpi_id, title')
      .eq('id', kpiId)
      .eq('user_id', userId)
      .single();

    if (kpiError || !kpi) {
      return NextResponse.json({ error: 'KPI not found' }, { status: 404 });
    }

    // Get what auto-calculation would produce for transparency
    const { data: children } = await supabase
      .from('vision_kpis')
      .select(`
        id,
        title,
        weight,
        kpi_progress_cache (progress_percentage)
      `)
      .eq('parent_kpi_id', kpiId)
      .eq('is_active', true);

    const weightedChildren: WeightedKPI[] = (children || []).map(c => ({
      id: c.id,
      title: c.title,
      progress: Number(c.kpi_progress_cache?.progress_percentage) || 0,
      weight: Number(c.weight) || 1,
    }));

    const autoCalcResult = calculateKpiProgress(kpiId, weightedChildren);

    // Determine status based on override percentage
    let status: 'not_started' | 'in_progress' | 'at_risk' | 'on_track' | 'completed' = 'in_progress';
    if (progressPercentage >= 100) status = 'completed';
    else if (progressPercentage === 0) status = 'not_started';
    else if (progressPercentage >= 70) status = 'on_track';
    else if (progressPercentage < 30) status = 'at_risk';

    // Update cache with manual override
    const { error: updateError } = await supabase
      .from('kpi_progress_cache')
      .upsert({
        kpi_id: kpiId,
        progress_percentage: progressPercentage.toFixed(2),
        weighted_progress: autoCalcResult.weightedProgress.toFixed(2), // Store what auto-calc would be
        child_count: autoCalcResult.childCount,
        completed_child_count: autoCalcResult.completedChildCount,
        total_weight: autoCalcResult.totalWeight.toFixed(2),
        status,
        calculation_method: 'manual_override',
        manual_override_reason: reason.trim(),
        last_calculated_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      }, { onConflict: 'kpi_id' });

    if (updateError) {
      console.error('Error setting override:', updateError);
      return NextResponse.json({ error: 'Failed to set override' }, { status: 500 });
    }

    // Recalculate parent if exists (parent is NOT protected by this KPI's override)
    if (kpi.parent_kpi_id) {
      await recalculateParentChain(supabase, kpi.parent_kpi_id);
    }

    return NextResponse.json({
      success: true,
      override: {
        kpiId,
        progressPercentage,
        reason: reason.trim(),
        autoCalculatedWouldBe: autoCalcResult.progressPercentage,
      },
    });
  } catch (error) {
    console.error('Set override error:', error);
    return NextResponse.json({ error: 'Failed to set override' }, { status: 500 });
  }
}

// DELETE /api/vision-kpis/[id]/override - Clear manual override
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: kpiId } = await params;
    const supabase = await createClient();
    if (!supabase) {
      return NextResponse.json({ error: 'Database connection failed' }, { status: 500 });
    }

    const userId = await getUserId(supabase);

    // Verify KPI belongs to user
    const { data: kpi, error: kpiError } = await supabase
      .from('vision_kpis')
      .select('id, parent_kpi_id')
      .eq('id', kpiId)
      .eq('user_id', userId)
      .single();

    if (kpiError || !kpi) {
      return NextResponse.json({ error: 'KPI not found' }, { status: 404 });
    }

    // Recalculate this KPI using auto calculation
    const { data: children } = await supabase
      .from('vision_kpis')
      .select(`
        id,
        title,
        weight,
        kpi_progress_cache (progress_percentage)
      `)
      .eq('parent_kpi_id', kpiId)
      .eq('is_active', true);

    const weightedChildren: WeightedKPI[] = (children || []).map(c => ({
      id: c.id,
      title: c.title,
      progress: Number(c.kpi_progress_cache?.progress_percentage) || 0,
      weight: Number(c.weight) || 1,
    }));

    const result = calculateKpiProgress(kpiId, weightedChildren);
    const cacheData = buildCacheUpdateData(result);

    // Update cache, clearing override
    const { error: updateError } = await supabase
      .from('kpi_progress_cache')
      .upsert({
        kpi_id: kpiId,
        ...cacheData,
        calculation_method: 'auto',
        manual_override_reason: null,
      }, { onConflict: 'kpi_id' });

    if (updateError) {
      console.error('Error clearing override:', updateError);
      return NextResponse.json({ error: 'Failed to clear override' }, { status: 500 });
    }

    // Recalculate parent if exists
    if (kpi.parent_kpi_id) {
      await recalculateParentChain(supabase, kpi.parent_kpi_id);
    }

    return NextResponse.json({
      success: true,
      newProgress: result.progressPercentage,
    });
  } catch (error) {
    console.error('Clear override error:', error);
    return NextResponse.json({ error: 'Failed to clear override' }, { status: 500 });
  }
}
```
  </action>
  <verify>
1. Directory exists: `src/app/api/vision-kpis/[id]/override/`
2. File exists at correct path
3. `npm run build` passes
4. POST requires progressPercentage and reason
5. DELETE clears override and triggers recalculation
  </verify>
  <done>Manual override endpoint allows setting/clearing overrides with reason</done>
</task>

</tasks>

<verification>
1. File exists:
   - `src/app/api/vision-kpis/[id]/override/route.ts`
2. `npm run build` passes without errors
3. Override endpoint requires reason parameter
4. Clearing override triggers parent recalculation
</verification>

<success_criteria>
- Manual override can be set with required explanation
- Manual override persists through automatic recalculations
- User can clear override to restore auto-calculation
- Parent progress is recalculated when override changes
</success_criteria>

<output>
After completion, create `.planning/phases/02-progress-calculation/02-04-SUMMARY.md`
</output>
