---
phase: 02-progress-calculation
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/app/api/vision-kpis/[id]/progress/route.ts
  - src/app/api/progress/formula/route.ts
  - src/lib/progress/ancestor-rollup.ts
autonomous: true

# Architecture decision: PROG-06 implementation
# Research concluded application-layer cache updates are preferred over database triggers.
# Reasons: (1) Better error handling, (2) Easier debugging, (3) No cross-language maintenance,
# (4) Works with Supabase client-side SDK. Cache updates happen synchronously in API routes.

must_haves:
  truths:
    - "Progress formula endpoint returns transparent calculation breakdown"
    - "Progress cache endpoint supports read, recalculate, and weight updates"
    - "Shared ancestor rollup function is reusable across endpoints"
  artifacts:
    - path: "src/app/api/vision-kpis/[id]/progress/route.ts"
      provides: "Progress cache update endpoint"
      exports: ["GET", "POST", "PUT"]
    - path: "src/app/api/progress/formula/route.ts"
      provides: "Formula transparency endpoint"
      exports: ["GET"]
    - path: "src/lib/progress/ancestor-rollup.ts"
      provides: "Shared ancestor rollup logic for reuse"
      exports: ["rollupProgressToAncestors"]
  key_links:
    - from: "src/app/api/vision-kpis/[id]/progress/route.ts"
      to: "src/lib/progress/calculator.ts"
      via: "import calculator"
      pattern: "import.*from.*progress"
    - from: "src/lib/progress/ancestor-rollup.ts"
      to: "src/lib/progress/rollup.ts"
      via: "import rollup functions"
      pattern: "import.*calculateKpiProgress.*buildCacheUpdateData"
---

<objective>
Create API endpoints for progress cache and formula transparency, plus a shared rollup utility.

Purpose: This implements PROG-05 (formula endpoint) and prepares the shared rollup logic for PROG-01/PROG-02.

Output: Progress API endpoints and reusable ancestor rollup module.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-progress-calculation/02-RESEARCH.md
@.planning/phases/02-progress-calculation/02-01-SUMMARY.md
@src/lib/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared ancestor rollup utility</name>
  <files>src/lib/progress/ancestor-rollup.ts</files>
  <action>
Create a reusable ancestor rollup function that can be imported by multiple endpoints:

```typescript
import { createClient } from '@/lib/supabase/server';
import { calculateKpiProgress, buildCacheUpdateData } from './rollup';
import type { WeightedKPI } from './types';

/**
 * Roll up progress to all ancestors after a KPI change.
 * This implements PROG-01 (parent updates) and PROG-02 (full chain rollup).
 *
 * Used by:
 * - /api/vision-kpis/[id]/log POST (after logging a KPI)
 * - /api/vision-kpis/[id]/override POST/DELETE (after setting/clearing override)
 * - /api/vision-kpis/[id]/progress PUT (after weight change)
 */
export async function rollupProgressToAncestors(
  supabase: Awaited<ReturnType<typeof createClient>>,
  kpiId: string
): Promise<{ updatedKpis: string[]; duration: number; error?: string }> {
  if (!supabase) return { updatedKpis: [], duration: 0 };

  const startTime = Date.now();
  const updatedKpis: string[] = [];

  try {
    // Get the KPI and its parent
    const { data: kpi } = await supabase
      .from('vision_kpis')
      .select('id, parent_kpi_id, level, numeric_target')
      .eq('id', kpiId)
      .single();

    if (!kpi) return { updatedKpis, duration: Date.now() - startTime };

    // Get most recent log for this KPI to determine its own progress
    const { data: latestLog } = await supabase
      .from('kpi_logs')
      .select('is_completed, value')
      .eq('kpi_id', kpiId)
      .order('log_date', { ascending: false })
      .limit(1)
      .single();

    // Calculate self progress for leaf KPIs
    let selfProgress = 0;
    if (latestLog?.is_completed) {
      selfProgress = 100;
    } else if (latestLog?.value && kpi.numeric_target) {
      selfProgress = Math.min(100, (Number(latestLog.value) / Number(kpi.numeric_target)) * 100);
    }

    // Update this KPI's cache entry
    await supabase
      .from('kpi_progress_cache')
      .upsert({
        kpi_id: kpiId,
        progress_percentage: selfProgress.toFixed(2),
        status: selfProgress >= 100 ? 'completed' : selfProgress > 0 ? 'in_progress' : 'not_started',
        calculation_method: 'auto',
        last_calculated_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      }, { onConflict: 'kpi_id' });

    updatedKpis.push(kpiId);

    // Traverse up the tree and update each ancestor
    let currentParentId = kpi.parent_kpi_id;

    while (currentParentId) {
      // Check if parent has manual override - if so, skip recalculation but continue traversal
      const { data: parentCache } = await supabase
        .from('kpi_progress_cache')
        .select('calculation_method')
        .eq('kpi_id', currentParentId)
        .single();

      if (parentCache?.calculation_method !== 'manual_override') {
        // Get children of this parent with their progress
        const { data: children } = await supabase
          .from('vision_kpis')
          .select(`
            id,
            title,
            weight,
            kpi_progress_cache (progress_percentage)
          `)
          .eq('parent_kpi_id', currentParentId)
          .eq('is_active', true);

        const weightedChildren: WeightedKPI[] = (children || []).map(c => ({
          id: c.id,
          title: c.title,
          progress: Number(c.kpi_progress_cache?.progress_percentage) || 0,
          weight: Number(c.weight) || 1,
        }));

        // Calculate and update parent's progress
        const result = calculateKpiProgress(currentParentId, weightedChildren);
        const cacheData = buildCacheUpdateData(result);

        await supabase
          .from('kpi_progress_cache')
          .upsert({
            kpi_id: currentParentId,
            ...cacheData,
          }, { onConflict: 'kpi_id' });

        updatedKpis.push(currentParentId);
      }

      // Move to next ancestor
      const { data: parent } = await supabase
        .from('vision_kpis')
        .select('parent_kpi_id')
        .eq('id', currentParentId)
        .single();

      currentParentId = parent?.parent_kpi_id;
    }

    return {
      updatedKpis,
      duration: Date.now() - startTime,
    };
  } catch (error) {
    console.error('Error in rollupProgressToAncestors:', error);
    return { updatedKpis, duration: Date.now() - startTime, error: String(error) };
  }
}

/**
 * Recalculate a single parent's progress (used after override changes).
 * Continues up the chain to recalculate all ancestors.
 */
export async function recalculateParentChain(
  supabase: Awaited<ReturnType<typeof createClient>>,
  parentKpiId: string
): Promise<void> {
  if (!supabase) return;

  try {
    let currentId: string | null = parentKpiId;

    while (currentId) {
      // Check if has manual override
      const { data: cache } = await supabase
        .from('kpi_progress_cache')
        .select('calculation_method')
        .eq('kpi_id', currentId)
        .single();

      if (cache?.calculation_method === 'manual_override') {
        // Stop - this KPI is protected
        break;
      }

      // Get children
      const { data: children } = await supabase
        .from('vision_kpis')
        .select(`
          id,
          title,
          weight,
          kpi_progress_cache (progress_percentage)
        `)
        .eq('parent_kpi_id', currentId)
        .eq('is_active', true);

      const weightedChildren: WeightedKPI[] = (children || []).map(c => ({
        id: c.id,
        title: c.title,
        progress: Number(c.kpi_progress_cache?.progress_percentage) || 0,
        weight: Number(c.weight) || 1,
      }));

      const result = calculateKpiProgress(currentId, weightedChildren);
      const cacheData = buildCacheUpdateData(result);

      await supabase
        .from('kpi_progress_cache')
        .upsert({
          kpi_id: currentId,
          ...cacheData,
        }, { onConflict: 'kpi_id' });

      // Get parent to continue chain
      const { data: kpi } = await supabase
        .from('vision_kpis')
        .select('parent_kpi_id')
        .eq('id', currentId)
        .single();

      currentId = kpi?.parent_kpi_id || null;
    }
  } catch (error) {
    console.error('Error in recalculateParentChain:', error);
  }
}
```
  </action>
  <verify>
1. File exists at `src/lib/progress/ancestor-rollup.ts`
2. `npm run build` passes
3. Exports rollupProgressToAncestors and recalculateParentChain
  </verify>
  <done>Shared ancestor rollup utility is available for import by API endpoints</done>
</task>

<task type="auto">
  <name>Task 2: Create progress cache endpoint</name>
  <files>src/app/api/vision-kpis/[id]/progress/route.ts</files>
  <action>
Create the progress cache API endpoint:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { calculateKpiProgress, buildCacheUpdateData } from '@/lib/progress/rollup';
import { recalculateParentChain } from '@/lib/progress/ancestor-rollup';
import type { WeightedKPI } from '@/lib/progress/types';

const DEMO_USER_ID = '00000000-0000-0000-0000-000000000001';

async function getUserId(supabase: Awaited<ReturnType<typeof createClient>>) {
  if (!supabase) return DEMO_USER_ID;
  const { data: { user } } = await supabase.auth.getUser();
  return user?.id || DEMO_USER_ID;
}

// GET /api/vision-kpis/[id]/progress - Get cached progress
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: kpiId } = await params;
    const supabase = await createClient();
    if (!supabase) {
      return NextResponse.json({ error: 'Database connection failed' }, { status: 500 });
    }

    const userId = await getUserId(supabase);

    // Fetch progress cache entry
    const { data: cache, error } = await supabase
      .from('kpi_progress_cache')
      .select('*')
      .eq('kpi_id', kpiId)
      .single();

    if (error && error.code !== 'PGRST116') {
      console.error('Error fetching progress cache:', error);
      return NextResponse.json({ error: 'Failed to fetch progress' }, { status: 500 });
    }

    // If no cache entry, calculate on demand
    if (!cache) {
      const { data: children } = await supabase
        .from('vision_kpis')
        .select(`
          id,
          title,
          weight,
          kpi_progress_cache (progress_percentage)
        `)
        .eq('parent_kpi_id', kpiId)
        .eq('is_active', true);

      const weightedChildren: WeightedKPI[] = (children || []).map(c => ({
        id: c.id,
        title: c.title,
        progress: Number(c.kpi_progress_cache?.progress_percentage) || 0,
        weight: Number(c.weight) || 1,
      }));

      const result = calculateKpiProgress(kpiId, weightedChildren);
      return NextResponse.json({ progress: result, cached: false });
    }

    return NextResponse.json({
      progress: {
        kpiId,
        progressPercentage: Number(cache.progress_percentage),
        childCount: cache.child_count,
        completedChildCount: cache.completed_child_count,
        weightedProgress: Number(cache.weighted_progress),
        totalWeight: Number(cache.total_weight),
        status: cache.status,
        calculationMethod: cache.calculation_method,
        manualOverrideReason: cache.manual_override_reason,
        lastCalculatedAt: cache.last_calculated_at,
      },
      cached: true,
    });
  } catch (error) {
    console.error('Get progress error:', error);
    return NextResponse.json({ error: 'Failed to fetch progress' }, { status: 500 });
  }
}

// POST /api/vision-kpis/[id]/progress - Recalculate and update cache
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const startTime = Date.now();

  try {
    const { id: kpiId } = await params;
    const supabase = await createClient();
    if (!supabase) {
      return NextResponse.json({ error: 'Database connection failed' }, { status: 500 });
    }

    const userId = await getUserId(supabase);

    // Check for force parameter and existing override
    const { searchParams } = new URL(request.url);
    const forceRecalculate = searchParams.get('force') === 'true';

    const { data: existingCache } = await supabase
      .from('kpi_progress_cache')
      .select('calculation_method')
      .eq('kpi_id', kpiId)
      .single();

    if (existingCache?.calculation_method === 'manual_override' && !forceRecalculate) {
      return NextResponse.json({
        progress: {
          kpiId,
          message: 'KPI has manual override, skipping auto-recalculation',
          manualOverride: true,
        },
        duration: Date.now() - startTime,
        skipped: true,
      });
    }

    // Get direct children with their progress
    const { data: children, error: childError } = await supabase
      .from('vision_kpis')
      .select(`
        id,
        title,
        weight,
        kpi_progress_cache (progress_percentage)
      `)
      .eq('parent_kpi_id', kpiId)
      .eq('is_active', true)
      .order('sort_order', { ascending: true });

    if (childError) {
      console.error('Error fetching children:', childError);
      return NextResponse.json({ error: 'Failed to fetch children' }, { status: 500 });
    }

    // Map to WeightedKPI format
    const weightedChildren: WeightedKPI[] = (children || []).map(c => ({
      id: c.id,
      title: c.title,
      progress: Number(c.kpi_progress_cache?.progress_percentage) || 0,
      weight: Number(c.weight) || 1,
    }));

    // Calculate progress
    const result = calculateKpiProgress(kpiId, weightedChildren);
    const cacheData = buildCacheUpdateData(result);

    // Upsert cache entry (clear override if force=true)
    const upsertData = forceRecalculate
      ? { kpi_id: kpiId, ...cacheData, calculation_method: 'auto', manual_override_reason: null }
      : { kpi_id: kpiId, ...cacheData };

    const { error: upsertError } = await supabase
      .from('kpi_progress_cache')
      .upsert(upsertData, { onConflict: 'kpi_id' });

    if (upsertError) {
      console.error('Error updating cache:', upsertError);
      return NextResponse.json({ error: 'Failed to update cache' }, { status: 500 });
    }

    const duration = Date.now() - startTime;

    return NextResponse.json({
      progress: result,
      duration,
      cached: true,
    });
  } catch (error) {
    console.error('Recalculate progress error:', error);
    return NextResponse.json({ error: 'Failed to recalculate progress' }, { status: 500 });
  }
}

// PUT /api/vision-kpis/[id]/progress - Update weight
export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: kpiId } = await params;
    const supabase = await createClient();
    if (!supabase) {
      return NextResponse.json({ error: 'Database connection failed' }, { status: 500 });
    }

    const userId = await getUserId(supabase);
    const body = await request.json();
    const { weight } = body;

    if (weight === undefined || weight < 0) {
      return NextResponse.json({ error: 'Valid weight is required' }, { status: 400 });
    }

    // Update weight on the KPI
    const { error: updateError } = await supabase
      .from('vision_kpis')
      .update({ weight, updated_at: new Date().toISOString() })
      .eq('id', kpiId)
      .eq('user_id', userId);

    if (updateError) {
      console.error('Error updating weight:', updateError);
      return NextResponse.json({ error: 'Failed to update weight' }, { status: 500 });
    }

    // Recalculate parent's progress since child weight changed
    const { data: kpi } = await supabase
      .from('vision_kpis')
      .select('parent_kpi_id')
      .eq('id', kpiId)
      .single();

    if (kpi?.parent_kpi_id) {
      await recalculateParentChain(supabase, kpi.parent_kpi_id);
    }

    return NextResponse.json({ success: true, weight });
  } catch (error) {
    console.error('Update weight error:', error);
    return NextResponse.json({ error: 'Failed to update weight' }, { status: 500 });
  }
}
```
  </action>
  <verify>
1. File exists at correct path
2. `npm run build` passes
3. Exports GET, POST, PUT handlers
4. POST respects manual override unless ?force=true
  </verify>
  <done>Progress endpoint provides cache read, recalculation, and weight updates with override protection</done>
</task>

<task type="auto">
  <name>Task 3: Create formula transparency endpoint</name>
  <files>src/app/api/progress/formula/route.ts</files>
  <action>
Create endpoint for transparent formula breakdown (PROG-05):

First create directory: `src/app/api/progress/formula/`

Then create the route file:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { buildProgressFormula } from '@/lib/progress/calculator';
import type { WeightedKPI, ProgressFormula } from '@/lib/progress/types';

const DEMO_USER_ID = '00000000-0000-0000-0000-000000000001';

async function getUserId(supabase: Awaited<ReturnType<typeof createClient>>) {
  if (!supabase) return DEMO_USER_ID;
  const { data: { user } } = await supabase.auth.getUser();
  return user?.id || DEMO_USER_ID;
}

// GET /api/progress/formula?kpiId=xxx - Get formula breakdown
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient();
    if (!supabase) {
      return NextResponse.json({ error: 'Database connection failed' }, { status: 500 });
    }

    const userId = await getUserId(supabase);
    const { searchParams } = new URL(request.url);
    const kpiId = searchParams.get('kpiId');

    if (!kpiId) {
      return NextResponse.json({ error: 'kpiId is required' }, { status: 400 });
    }

    // Get KPI details and its children
    const { data: kpi, error: kpiError } = await supabase
      .from('vision_kpis')
      .select('id, title, level, parent_kpi_id')
      .eq('id', kpiId)
      .single();

    if (kpiError || !kpi) {
      return NextResponse.json({ error: 'KPI not found' }, { status: 404 });
    }

    // Get children with their progress
    const { data: children, error: childError } = await supabase
      .from('vision_kpis')
      .select(`
        id,
        title,
        weight,
        kpi_progress_cache (
          progress_percentage,
          calculation_method,
          manual_override_reason
        )
      `)
      .eq('parent_kpi_id', kpiId)
      .eq('is_active', true)
      .order('sort_order', { ascending: true });

    if (childError) {
      console.error('Error fetching children:', childError);
      return NextResponse.json({ error: 'Failed to fetch children' }, { status: 500 });
    }

    // Get cache entry for override info
    const { data: cache } = await supabase
      .from('kpi_progress_cache')
      .select('calculation_method, manual_override_reason, progress_percentage')
      .eq('kpi_id', kpiId)
      .single();

    const isManualOverride = cache?.calculation_method === 'manual_override';

    // Build WeightedKPI array
    const weightedChildren: WeightedKPI[] = (children || []).map(c => ({
      id: c.id,
      title: c.title,
      progress: Number(c.kpi_progress_cache?.progress_percentage) || 0,
      weight: Number(c.weight) || 1,
    }));

    // Build formula with override info if applicable
    const formula: ProgressFormula = buildProgressFormula(
      weightedChildren,
      isManualOverride
        ? {
            manualOverride: Number(cache.progress_percentage),
            overrideReason: cache.manual_override_reason,
          }
        : undefined
    );

    return NextResponse.json({
      kpiId,
      kpiTitle: kpi.title,
      level: kpi.level,
      parentKpiId: kpi.parent_kpi_id,
      formula,
      children: weightedChildren.map(c => ({
        id: c.id,
        title: c.title,
        progress: c.progress,
        weight: c.weight,
        contributionPercent: formula.components.find(comp => comp.kpiId === c.id)?.contribution || 0,
      })),
    });
  } catch (error) {
    console.error('Get formula error:', error);
    return NextResponse.json({ error: 'Failed to get formula' }, { status: 500 });
  }
}
```
  </action>
  <verify>
1. Directory exists: `src/app/api/progress/formula/`
2. File exists at correct path
3. `npm run build` passes
4. Endpoint returns formula breakdown structure
  </verify>
  <done>Formula endpoint exposes transparent calculation breakdown for UI</done>
</task>

</tasks>

<verification>
1. All files exist:
   - `src/lib/progress/ancestor-rollup.ts`
   - `src/app/api/vision-kpis/[id]/progress/route.ts`
   - `src/app/api/progress/formula/route.ts`
2. `npm run build` passes without errors
3. Shared rollup utility is imported correctly
4. Formula endpoint returns ProgressFormula structure
</verification>

<success_criteria>
- Progress cache endpoint supports read, recalculate, and weight updates
- Formula endpoint provides transparent calculation breakdown
- Shared rollup utility exists for reuse by other endpoints
- Override protection is respected in POST handler
</success_criteria>

<output>
After completion, create `.planning/phases/02-progress-calculation/02-02-SUMMARY.md`
</output>
