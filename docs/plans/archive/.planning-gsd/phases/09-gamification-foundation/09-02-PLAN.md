# Plan 09-02: Gamification Service and API Integration

## Objective

Create the gamification service layer with XP calculation, level progression, and achievement checking. Build API endpoints to fetch user stats and achievements. Integrate with KPI completion flow to award XP and trigger achievement checks.

## Execution Context

**Phase**: 9 - Gamification Foundation
**Depends on**: Plan 09-01 (schema must be deployed)
**Scope**: ~400 lines across service, API routes, and integration

**Reference files**:
- `src/lib/utils/progress.ts` - existing service pattern
- `src/app/api/kpis/[id]/log/route.ts` - KPI completion endpoint to integrate with
- `src/types/gamification.ts` - types from Plan 09-01

## Context

**Integration points**:
- KPI completion (`POST /api/kpis/[id]/log`) - award XP, check achievements
- Vision creation (`POST /api/visions`) - award XP, check first_vision achievement
- Streak updates (existing `kpiStreaks` table) - check streak achievements

**Service responsibilities**:
1. Award XP and update level
2. Check and unlock achievements
3. Update streak counters
4. Return newly unlocked achievements for UI celebration

## Tasks

### Task 1: Create gamification service
**File**: `src/lib/services/gamification.ts` (new file)
**Action**: Create core service with XP and achievement logic

```typescript
import { adminClient } from '@/lib/supabase/admin';
import { LEVEL_THRESHOLDS, XP_REWARDS, type Achievement, type UserGamification } from '@/types/gamification';

export interface GamificationResult {
  xpAwarded: number;
  newLevel: number | null; // Only set if leveled up
  unlockedAchievements: Achievement[];
  currentXp: number;
  currentLevel: number;
}

/**
 * Calculate level from total XP
 */
export function calculateLevel(totalXp: number): number {
  let level = 1;
  for (let i = 1; i < LEVEL_THRESHOLDS.length; i++) {
    if (totalXp >= LEVEL_THRESHOLDS[i]) {
      level = i + 1;
    } else {
      break;
    }
  }
  // Handle levels beyond defined thresholds
  if (totalXp >= LEVEL_THRESHOLDS[LEVEL_THRESHOLDS.length - 1]) {
    const beyondXp = totalXp - LEVEL_THRESHOLDS[LEVEL_THRESHOLDS.length - 1];
    level = LEVEL_THRESHOLDS.length + Math.floor(beyondXp / 1000);
  }
  return level;
}

/**
 * Get or create user gamification record
 */
export async function getOrCreateUserGamification(userId: string): Promise<UserGamification> {
  const { data: existing } = await adminClient
    .from('user_gamification')
    .select('*')
    .eq('user_id', userId)
    .single();

  if (existing) {
    return transformGamification(existing);
  }

  // Create new record
  const { data: created, error } = await adminClient
    .from('user_gamification')
    .insert({ user_id: userId })
    .select()
    .single();

  if (error) throw error;
  return transformGamification(created);
}

/**
 * Award XP for an action and check for achievements
 */
export async function awardXp(
  userId: string,
  action: keyof typeof XP_REWARDS,
  metadata?: { kpiId?: string; streakCount?: number }
): Promise<GamificationResult> {
  const xpAmount = XP_REWARDS[action];
  const gamification = await getOrCreateUserGamification(userId);

  const newTotalXp = gamification.totalXp + xpAmount;
  const previousLevel = gamification.currentLevel;
  const newLevel = calculateLevel(newTotalXp);
  const leveledUp = newLevel > previousLevel;

  // Update counters based on action
  const updates: Record<string, unknown> = {
    total_xp: newTotalXp,
    current_level: newLevel,
    updated_at: new Date().toISOString(),
    last_activity_date: new Date().toISOString().split('T')[0],
  };

  if (action === 'KPI_COMPLETED') {
    updates.kpis_completed = gamification.kpisCompleted + 1;
  } else if (action === 'VISION_CREATED') {
    updates.visions_created = gamification.visionsCreated + 1;
  }

  // Update streak if provided
  if (metadata?.streakCount !== undefined) {
    updates.current_streak = metadata.streakCount;
    if (metadata.streakCount > gamification.longestStreak) {
      updates.longest_streak = metadata.streakCount;
    }
  }

  await adminClient
    .from('user_gamification')
    .update(updates)
    .eq('user_id', userId);

  // Check for new achievements
  const unlockedAchievements = await checkAndUnlockAchievements(userId, {
    ...gamification,
    totalXp: newTotalXp,
    currentLevel: newLevel,
    kpisCompleted: (updates.kpis_completed as number) ?? gamification.kpisCompleted,
    visionsCreated: (updates.visions_created as number) ?? gamification.visionsCreated,
    currentStreak: (updates.current_streak as number) ?? gamification.currentStreak,
    longestStreak: (updates.longest_streak as number) ?? gamification.longestStreak,
  });

  // Award bonus XP for achievements
  let bonusXp = 0;
  for (const achievement of unlockedAchievements) {
    bonusXp += achievement.xpReward;
  }

  if (bonusXp > 0) {
    await adminClient
      .from('user_gamification')
      .update({
        total_xp: newTotalXp + bonusXp,
        current_level: calculateLevel(newTotalXp + bonusXp),
      })
      .eq('user_id', userId);
  }

  return {
    xpAwarded: xpAmount + bonusXp,
    newLevel: leveledUp ? newLevel : null,
    unlockedAchievements,
    currentXp: newTotalXp + bonusXp,
    currentLevel: calculateLevel(newTotalXp + bonusXp),
  };
}

/**
 * Check achievement conditions and unlock any earned
 */
async function checkAndUnlockAchievements(
  userId: string,
  stats: UserGamification
): Promise<Achievement[]> {
  // Get all achievements and user's unlocked ones
  const [{ data: allAchievements }, { data: userAchievements }] = await Promise.all([
    adminClient.from('achievements').select('*'),
    adminClient.from('user_achievements').select('achievement_id').eq('user_id', userId),
  ]);

  const unlockedIds = new Set(userAchievements?.map(ua => ua.achievement_id) || []);
  const newlyUnlocked: Achievement[] = [];

  for (const achievement of allAchievements || []) {
    if (unlockedIds.has(achievement.id)) continue;

    const shouldUnlock = checkAchievementCondition(achievement, stats);
    if (shouldUnlock) {
      await adminClient.from('user_achievements').insert({
        user_id: userId,
        achievement_id: achievement.id,
      });
      newlyUnlocked.push(transformAchievement(achievement));
    }
  }

  return newlyUnlocked;
}

/**
 * Check if achievement condition is met
 */
function checkAchievementCondition(
  achievement: { key: string; required_value: number | null },
  stats: UserGamification
): boolean {
  const required = achievement.required_value || 0;

  switch (achievement.key) {
    // Exploration
    case 'first_vision':
      return stats.visionsCreated >= 1;
    case 'first_kpi':
      return stats.kpisCompleted >= 1;

    // Milestones
    case 'kpi_10':
      return stats.kpisCompleted >= 10;
    case 'kpi_50':
      return stats.kpisCompleted >= 50;
    case 'kpi_100':
      return stats.kpisCompleted >= 100;
    case 'kpi_500':
      return stats.kpisCompleted >= 500;

    // Streaks
    case 'streak_7':
      return stats.longestStreak >= 7;
    case 'streak_30':
      return stats.longestStreak >= 30;
    case 'streak_100':
      return stats.longestStreak >= 100;

    // Mastery (levels)
    case 'level_5':
      return stats.currentLevel >= 5;
    case 'level_10':
      return stats.currentLevel >= 10;

    default:
      // Generic check for any achievement with required_value
      return false;
  }
}

// Transform database row to TypeScript type
function transformGamification(row: Record<string, unknown>): UserGamification {
  return {
    id: row.id as string,
    userId: row.user_id as string,
    totalXp: row.total_xp as number,
    currentLevel: row.current_level as number,
    kpisCompleted: row.kpis_completed as number,
    visionsCreated: row.visions_created as number,
    longestStreak: row.longest_streak as number,
    currentStreak: row.current_streak as number,
    lastActivityDate: row.last_activity_date as string | null,
    createdAt: new Date(row.created_at as string),
    updatedAt: new Date(row.updated_at as string),
  };
}

function transformAchievement(row: Record<string, unknown>): Achievement {
  return {
    id: row.id as string,
    key: row.key as string,
    name: row.name as string,
    description: row.description as string,
    category: row.category as Achievement['category'],
    iconName: row.icon_name as string | null,
    xpReward: row.xp_reward as number,
    requiredValue: row.required_value as number | null,
    isSecret: row.is_secret as boolean,
    createdAt: new Date(row.created_at as string),
  };
}
```

### Task 2: Create gamification stats API endpoint
**File**: `src/app/api/gamification/stats/route.ts` (new file)
**Action**: GET endpoint for user's gamification stats

```typescript
import { NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { getOrCreateUserGamification } from '@/lib/services/gamification';

const DEMO_USER_ID = '4e93a72c-e2b6-4cf4-8ff4-1dbe34d0f3f1';

export async function GET() {
  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    const userId = user?.id || DEMO_USER_ID;

    const gamification = await getOrCreateUserGamification(userId);

    return NextResponse.json(gamification);
  } catch (error) {
    console.error('Error fetching gamification stats:', error);
    return NextResponse.json(
      { error: 'Failed to fetch gamification stats' },
      { status: 500 }
    );
  }
}
```

### Task 3: Create achievements API endpoint
**File**: `src/app/api/gamification/achievements/route.ts` (new file)
**Action**: GET endpoint for user's achievements with progress

```typescript
import { NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { adminClient } from '@/lib/supabase/admin';
import { getOrCreateUserGamification } from '@/lib/services/gamification';

const DEMO_USER_ID = '4e93a72c-e2b6-4cf4-8ff4-1dbe34d0f3f1';

export async function GET() {
  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    const userId = user?.id || DEMO_USER_ID;

    // Get all achievements
    const { data: achievements } = await adminClient
      .from('achievements')
      .select('*')
      .order('category', { ascending: true });

    // Get user's unlocked achievements
    const { data: userAchievements } = await adminClient
      .from('user_achievements')
      .select('achievement_id, unlocked_at')
      .eq('user_id', userId);

    // Get user stats for progress calculation
    const stats = await getOrCreateUserGamification(userId);

    const unlockedMap = new Map(
      userAchievements?.map(ua => [ua.achievement_id, ua.unlocked_at]) || []
    );

    // Map achievements with unlock status and progress
    const result = achievements?.map(a => ({
      id: a.id,
      key: a.key,
      name: a.name,
      description: a.description,
      category: a.category,
      iconName: a.icon_name,
      xpReward: a.xp_reward,
      requiredValue: a.required_value,
      isSecret: a.is_secret,
      unlocked: unlockedMap.has(a.id),
      unlockedAt: unlockedMap.get(a.id) || null,
      progress: calculateProgress(a.key, a.required_value, stats),
    })) || [];

    return NextResponse.json(result);
  } catch (error) {
    console.error('Error fetching achievements:', error);
    return NextResponse.json(
      { error: 'Failed to fetch achievements' },
      { status: 500 }
    );
  }
}

function calculateProgress(
  key: string,
  requiredValue: number | null,
  stats: { kpisCompleted: number; visionsCreated: number; longestStreak: number; currentLevel: number }
): number {
  if (!requiredValue) return 0;

  let current = 0;
  if (key.startsWith('kpi_') || key === 'first_kpi') {
    current = stats.kpisCompleted;
  } else if (key.startsWith('streak_')) {
    current = stats.longestStreak;
  } else if (key === 'first_vision') {
    current = stats.visionsCreated;
  } else if (key.startsWith('level_')) {
    current = stats.currentLevel;
  }

  return Math.min(100, Math.round((current / requiredValue) * 100));
}
```

### Task 4: Integrate with KPI completion endpoint
**File**: `src/app/api/kpis/[id]/log/route.ts`
**Action**: Add gamification call after successful KPI log

Find the existing POST handler and add gamification integration:

```typescript
// Add import at top
import { awardXp } from '@/lib/services/gamification';

// Inside POST handler, after successful kpi_logs insert:
// Award XP for KPI completion
let gamificationResult = null;
try {
  // Get current streak from kpi_streaks if exists
  const { data: streakData } = await adminClient
    .from('kpi_streaks')
    .select('current_streak')
    .eq('kpi_id', id)
    .single();

  gamificationResult = await awardXp(userId, 'KPI_COMPLETED', {
    kpiId: id,
    streakCount: streakData?.current_streak,
  });
} catch (gamificationError) {
  // Log but don't fail the request
  console.error('Gamification error:', gamificationError);
}

// Include gamification result in response
return NextResponse.json({
  ...existingResponse,
  gamification: gamificationResult,
});
```

### Task 5: Integrate with vision creation endpoint
**File**: `src/app/api/visions/route.ts`
**Action**: Add gamification call after successful vision creation

Find the existing POST handler and add:

```typescript
// Add import at top
import { awardXp } from '@/lib/services/gamification';

// Inside POST handler, after successful vision insert:
// Award XP for vision creation
let gamificationResult = null;
try {
  gamificationResult = await awardXp(userId, 'VISION_CREATED');
} catch (gamificationError) {
  console.error('Gamification error:', gamificationError);
}

// Include in response
return NextResponse.json({
  ...existingResponse,
  gamification: gamificationResult,
});
```

### Task 6: Create React Query hooks
**File**: `src/lib/hooks/use-gamification.ts` (new file)
**Action**: Create hooks for fetching gamification data

```typescript
import { useQuery } from '@tanstack/react-query';
import type { UserGamification, Achievement } from '@/types/gamification';

export interface AchievementWithProgress extends Achievement {
  unlocked: boolean;
  unlockedAt: string | null;
  progress: number;
}

export function useGamificationStats() {
  return useQuery<UserGamification>({
    queryKey: ['gamification', 'stats'],
    queryFn: async () => {
      const res = await fetch('/api/gamification/stats');
      if (!res.ok) throw new Error('Failed to fetch gamification stats');
      return res.json();
    },
    staleTime: 60 * 1000, // 1 minute
  });
}

export function useAchievements() {
  return useQuery<AchievementWithProgress[]>({
    queryKey: ['gamification', 'achievements'],
    queryFn: async () => {
      const res = await fetch('/api/gamification/achievements');
      if (!res.ok) throw new Error('Failed to fetch achievements');
      return res.json();
    },
    staleTime: 60 * 1000,
  });
}

// Query key factory for cache invalidation
export const gamificationKeys = {
  all: ['gamification'] as const,
  stats: () => [...gamificationKeys.all, 'stats'] as const,
  achievements: () => [...gamificationKeys.all, 'achievements'] as const,
};
```

### Task 7: Add barrel exports
**File**: `src/lib/services/index.ts`
**Action**: Export gamification service (create file if doesn't exist)

```typescript
export * from './gamification';
```

**File**: `src/lib/hooks/index.ts`
**Action**: Export gamification hooks (create or update)

```typescript
export * from './use-gamification';
```

## Verification

1. **Service tests**: Manually test awardXp with different actions
2. **API tests**:
   - `GET /api/gamification/stats` returns user stats
   - `GET /api/gamification/achievements` returns all achievements with progress
3. **Integration tests**:
   - Create KPI log → XP awarded, gamification in response
   - Create vision → XP awarded
   - Hit milestone → achievement unlocked, bonus XP

## Success Criteria

- [ ] Gamification service with awardXp, calculateLevel functions
- [ ] GET /api/gamification/stats endpoint working
- [ ] GET /api/gamification/achievements endpoint with progress
- [ ] KPI completion awards XP and checks achievements
- [ ] Vision creation awards XP
- [ ] React Query hooks exported
- [ ] Unlocked achievements returned in API responses for UI celebrations
- [ ] All builds pass

## Output

After completing this plan:
- Full gamification backend operational
- XP awarded on KPI completion and vision creation
- Achievement progress tracked
- Ready for Phase 10 (Streaks & Daily Goals UI) and Phase 11 (Visual Celebrations)
