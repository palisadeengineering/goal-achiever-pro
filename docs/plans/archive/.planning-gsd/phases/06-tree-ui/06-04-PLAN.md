---
phase: 06-tree-ui
plan: 04
type: execute
wave: 2
depends_on: ["06-03"]
files_modified:
  - src/components/features/kpi/goal-tree-view.tsx
  - src/components/features/kpi/goal-tree-node.tsx
  - src/components/features/kpi/goal-tree-context.tsx
autonomous: true

must_haves:
  truths:
    - "Arrow keys navigate between visible tree items"
    - "Home key jumps to first item, End key jumps to last"
    - "Collapsing a focused child moves focus to parent"
    - "Empty tree shows helpful message with action"
    - "Tree nodes are memoized to prevent unnecessary re-renders"
  artifacts:
    - path: "src/components/features/kpi/goal-tree-view.tsx"
      provides: "Roving tabindex keyboard navigation"
    - path: "src/components/features/kpi/goal-tree-node.tsx"
      provides: "Memoized node component"
---

<objective>
Polish the GoalTreeView with proper keyboard navigation, edge case handling, and performance optimization. Focus on fixing the arrow key navigation between treeitems and handling empty/error states gracefully.

Purpose: Complete TREE-06 (keyboard navigation) requirement and ensure robust UX for edge cases.

Output: Fully accessible tree with arrow key navigation, empty states, and optimized rendering.
</objective>

<context>
@.planning/phases/06-tree-ui/06-03-SUMMARY.md
@.planning/phases/06-tree-ui/06-RESEARCH.md
@src/components/features/kpi/goal-tree-view.tsx
@src/components/features/kpi/goal-tree-node.tsx
@src/components/features/kpi/goal-tree-context.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add roving tabindex keyboard navigation</name>
  <files>src/components/features/kpi/goal-tree-view.tsx</files>
  <action>
Implement proper arrow key navigation between treeitems using roving tabindex pattern.

1. **Add focusedId state to context or local state:**
   ```typescript
   const [focusedId, setFocusedId] = useState<string | null>(null);
   ```

2. **Create keyboard handler on tree container:**
   ```typescript
   const handleTreeKeyDown = useCallback((e: React.KeyboardEvent) => {
     const tree = treeRef.current;
     if (!tree) return;

     // Get all visible treeitems (not hidden by collapsed parents)
     const items = Array.from(tree.querySelectorAll('[role="treeitem"]:not([hidden])'));
     const currentIndex = items.findIndex(
       item => item.getAttribute('data-id') === focusedId
     );

     let nextIndex = currentIndex;

     switch (e.key) {
       case 'ArrowDown':
         e.preventDefault();
         nextIndex = Math.min(currentIndex + 1, items.length - 1);
         break;
       case 'ArrowUp':
         e.preventDefault();
         nextIndex = Math.max(currentIndex - 1, 0);
         break;
       case 'Home':
         e.preventDefault();
         nextIndex = 0;
         break;
       case 'End':
         e.preventDefault();
         nextIndex = items.length - 1;
         break;
       default:
         return;
     }

     if (nextIndex !== currentIndex && items[nextIndex]) {
       const newId = items[nextIndex].getAttribute('data-id');
       if (newId) {
         setFocusedId(newId);
         (items[nextIndex] as HTMLElement).focus();
       }
     }
   }, [focusedId]);
   ```

3. **Add onKeyDown to tree element:**
   ```tsx
   <ul
     ref={treeRef}
     role="tree"
     aria-label={`${visionTitle} goal hierarchy`}
     className="space-y-1"
     onKeyDown={handleTreeKeyDown}
   >
   ```

4. **Pass focusedId to GoalTreeNode:**
   Add `focusedId` and `setFocusedId` props to nodes so they can set tabIndex correctly.
  </action>
  <verify>
Build passes and no TypeScript errors.
  </verify>
  <done>Arrow keys navigate between visible treeitems with roving tabindex.</done>
</task>

<task type="auto">
  <name>Task 2: Update GoalTreeNode for roving tabindex</name>
  <files>src/components/features/kpi/goal-tree-node.tsx</files>
  <action>
Update GoalTreeNode to support roving tabindex pattern.

1. **Accept focusedId prop:**
   ```typescript
   interface GoalTreeNodeProps {
     node: KpiTreeNode;
     level: number;
     posInSet: number;
     setSize: number;
     onLogKpi?: (kpiId: string, complete: boolean) => void;
     focusedId: string | null;
     onFocus: (id: string) => void;
   }
   ```

2. **Set tabIndex based on focus:**
   ```typescript
   const isFocused = focusedId === node.id;

   // On the treeitem li element:
   tabIndex={isFocused ? 0 : -1}
   data-id={node.id}
   onFocus={() => onFocus(node.id)}
   ```

3. **Add focus ring styling:**
   ```typescript
   className={cn(
     'outline-none cursor-pointer',
     isFocused && 'ring-2 ring-ring ring-offset-2 ring-offset-background rounded-md'
   )}
   ```

4. **Memoize the component:**
   ```typescript
   export const GoalTreeNode = memo(function GoalTreeNode({ ... }: GoalTreeNodeProps) {
     // ... implementation
   });
   ```

5. **Pass props to children:**
   ```tsx
   {visibleChildren.map((child, index) => (
     <GoalTreeNode
       key={child.id}
       node={child}
       level={level + 1}
       posInSet={index + 1}
       setSize={visibleChildren.length}
       onLogKpi={onLogKpi}
       focusedId={focusedId}
       onFocus={onFocus}
     />
   ))}
   ```
  </action>
  <verify>
TypeScript compilation passes.
  </verify>
  <done>GoalTreeNode supports roving tabindex with proper focus styling and memoization.</done>
</task>

<task type="auto">
  <name>Task 3: Handle focus on collapse</name>
  <files>src/components/features/kpi/goal-tree-node.tsx</files>
  <action>
When a parent node collapses, if any of its children had focus, move focus to the parent.

1. **Track previous focusedId:**
   Use useEffect to detect when focusedId changes and a child is being hidden.

2. **In toggle handler, check if collapsing with focused child:**
   ```typescript
   const handleToggle = useCallback(() => {
     const wasExpanded = expandedIds.has(node.id);

     if (wasExpanded) {
       // Check if any descendant has focus
       const hasDescendantFocus = node.children?.some(child => {
         // Recursively check if child or its descendants are focused
         return isDescendantFocused(child, focusedId);
       });

       if (hasDescendantFocus) {
         // Move focus to this node before collapsing
         onFocus(node.id);
       }
     }

     toggleExpanded(node.id);
   }, [node.id, node.children, focusedId, expandedIds, toggleExpanded, onFocus]);

   // Helper function
   function isDescendantFocused(node: KpiTreeNode, focusedId: string | null): boolean {
     if (!focusedId) return false;
     if (node.id === focusedId) return true;
     return node.children?.some(child => isDescendantFocused(child, focusedId)) ?? false;
   }
   ```
  </action>
  <verify>
Manual test: Focus a child node, collapse parent, verify focus moves to parent.
  </verify>
  <done>Collapsing a node with focused descendants moves focus to the collapsed node.</done>
</task>

<task type="auto">
  <name>Task 4: Add empty state handling</name>
  <files>src/components/features/kpi/goal-tree-view.tsx</files>
  <action>
Show a helpful empty state when the tree has no KPIs.

1. **Check for empty tree:**
   ```typescript
   const isEmpty = !data?.tree || data.tree.length === 0;
   ```

2. **Render empty state:**
   ```tsx
   {isEmpty && !isLoading && (
     <div className="text-center py-8 border rounded-lg bg-muted/20">
       <Target className="h-12 w-12 mx-auto text-muted-foreground mb-4" />
       <h4 className="font-medium mb-2">No KPIs yet</h4>
       <p className="text-sm text-muted-foreground mb-4">
         Generate KPIs from your vision to start tracking progress.
       </p>
       <Button variant="outline" size="sm" asChild>
         <Link href={`/vision/${visionId}?tab=plan`}>
           View Plan
         </Link>
       </Button>
     </div>
   )}
   ```

3. **Import required components:**
   - Target from lucide-react
   - Link from next/link
  </action>
  <verify>
Empty state appears when tree has no items.
  </verify>
  <done>Empty tree shows helpful message with link to Plan tab.</done>
</task>

<task type="auto">
  <name>Task 5: Improve error handling</name>
  <files>src/components/features/kpi/goal-tree-view.tsx</files>
  <action>
Improve the error state with retry functionality.

1. **Enhance error display:**
   ```tsx
   {error && (
     <div className="text-center py-8 border border-destructive/20 rounded-lg bg-destructive/5">
       <AlertCircle className="h-8 w-8 mx-auto text-destructive mb-3" />
       <h4 className="font-medium text-destructive mb-2">Failed to load KPIs</h4>
       <p className="text-sm text-muted-foreground mb-4">
         {error.message || 'An error occurred while loading the goal tree.'}
       </p>
       <Button variant="outline" size="sm" onClick={() => refetch()}>
         <RefreshCw className="h-4 w-4 mr-2" />
         Try Again
       </Button>
     </div>
   )}
   ```

2. **Make sure refetch is available from useGoalTree:**
   The hook should already return refetch from React Query.
  </action>
  <verify>
Error state shows retry button that refetches data.
  </verify>
  <done>Error state has helpful message and retry button.</done>
</task>

</tasks>

<verification>
1. Keyboard navigation test:
   - Focus first treeitem
   - Arrow Down moves to next
   - Arrow Up moves to previous
   - Home jumps to first
   - End jumps to last

2. Focus management test:
   - Focus a nested child
   - Collapse parent
   - Verify focus moves to parent

3. Empty state test:
   - View a vision with no KPIs
   - Verify empty state message appears

4. Error handling test:
   - Simulate network error (optional)
   - Verify error message and retry button
</verification>

<success_criteria>
- Arrow keys navigate between visible treeitems
- Focus ring clearly visible on focused item
- Collapsing moves focus appropriately
- Empty tree shows helpful empty state
- Error state has retry functionality
- GoalTreeNode is memoized
- TREE-06 requirement fully complete
</success_criteria>

<output>
After completion, update `.planning/phases/06-tree-ui/06-04-SUMMARY.md`
Then update STATE.md to mark Phase 6 as complete.
</output>
