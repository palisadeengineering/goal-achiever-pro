# Plan 10-01: MINS CRUD API and Database Integration

## Objective

Create full CRUD API for MINS (Most Important Next Steps), React Query hooks, and convert the MINS page from mock data to real database integration. This is critical as the MINS page is currently non-functional with hardcoded mock data.

## Execution Context

**Phase**: 10 - Streaks & Daily Goals
**Depends on**: v1.0 complete (database schema for mins already exists)
**Scope**: ~600 lines across API routes, hooks, and page refactor

**Reference files**:
- `src/lib/db/schema.ts` (lines 315-345) - mins table schema
- `src/app/(dashboard)/mins/page.tsx` - current mock implementation
- `src/app/api/today/route.ts` - similar API pattern for daily_actions
- `src/lib/hooks/use-gamification.ts` - React Query hooks pattern

## Context

**Current state**:
- MINS page exists but uses mock data (mockMins array)
- Database schema for `mins` table already exists
- MinForm component exists but saves to local state only

**Target state**:
- Full CRUD operations via API
- Real-time data from database
- React Query integration with optimistic updates
- Proper error handling

## Tasks

### Task 1: Create MINS list API endpoint
**File**: `src/app/api/mins/route.ts` (new file)
**Action**: Create GET and POST endpoints for MINS

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';

const DEMO_USER_ID = '00000000-0000-0000-0000-000000000001';

async function getUserId(supabase: Awaited<ReturnType<typeof createClient>>) {
  if (!supabase) return DEMO_USER_ID;
  const { data: { user } } = await supabase.auth.getUser();
  return user?.id || DEMO_USER_ID;
}

// GET /api/mins - List MINS with optional filters
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient();
    if (!supabase) {
      return NextResponse.json({ error: 'Database connection failed' }, { status: 500 });
    }

    const userId = await getUserId(supabase);
    const { searchParams } = new URL(request.url);

    const date = searchParams.get('date'); // specific date
    const timeScope = searchParams.get('timeScope'); // 'daily' | 'weekly' | 'all'
    const status = searchParams.get('status'); // 'pending' | 'completed' | 'all'
    const impactProjectId = searchParams.get('impactProjectId');

    let query = supabase
      .from('mins')
      .select(`
        *,
        impact_projects:power_goals (
          id,
          title,
          category,
          visions (
            id,
            title,
            color
          )
        )
      `)
      .eq('user_id', userId)
      .order('priority', { ascending: true })
      .order('scheduled_time', { ascending: true, nullsFirst: false });

    if (date) {
      query = query.eq('scheduled_date', date);
    }

    if (timeScope && timeScope !== 'all') {
      query = query.eq('time_scope', timeScope);
    }

    if (status && status !== 'all') {
      query = query.eq('status', status);
    }

    if (impactProjectId) {
      query = query.eq('power_goal_id', impactProjectId);
    }

    const { data, error } = await query;

    if (error) {
      console.error('Error fetching MINS:', error);
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json({ mins: data || [] });
  } catch (error) {
    console.error('GET /api/mins error:', error);
    return NextResponse.json({ error: 'Failed to fetch MINS' }, { status: 500 });
  }
}

// POST /api/mins - Create new MIN
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient();
    if (!supabase) {
      return NextResponse.json({ error: 'Database connection failed' }, { status: 500 });
    }

    const userId = await getUserId(supabase);
    const body = await request.json();

    const {
      title,
      description,
      scheduledDate,
      scheduledTime,
      durationMinutes = 30,
      priority = 1,
      timeScope = 'daily',
      weekStartDate,
      weekEndDate,
      valueQuadrant,
      makesMoneyScore,
      energyScore,
      impactProjectId,
      isRecurring = false,
      recurrenceRule,
    } = body;

    if (!title || !scheduledDate) {
      return NextResponse.json(
        { error: 'Title and scheduled date are required' },
        { status: 400 }
      );
    }

    const { data, error } = await supabase
      .from('mins')
      .insert({
        user_id: userId,
        title,
        description,
        scheduled_date: scheduledDate,
        scheduled_time: scheduledTime,
        duration_minutes: durationMinutes,
        priority,
        time_scope: timeScope,
        week_start_date: weekStartDate,
        week_end_date: weekEndDate,
        drip_quadrant: valueQuadrant,
        makes_money_score: makesMoneyScore,
        energy_score: energyScore,
        power_goal_id: impactProjectId,
        is_recurring: isRecurring,
        recurrence_rule: recurrenceRule,
        status: 'pending',
      })
      .select(`
        *,
        impact_projects:power_goals (
          id,
          title,
          category,
          visions (id, title, color)
        )
      `)
      .single();

    if (error) {
      console.error('Error creating MIN:', error);
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json({ min: data }, { status: 201 });
  } catch (error) {
    console.error('POST /api/mins error:', error);
    return NextResponse.json({ error: 'Failed to create MIN' }, { status: 500 });
  }
}
```

### Task 2: Create single MIN API endpoint
**File**: `src/app/api/mins/[id]/route.ts` (new file)
**Action**: Create GET, PUT, DELETE for individual MINS

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { awardXp } from '@/lib/services/gamification';

const DEMO_USER_ID = '00000000-0000-0000-0000-000000000001';

async function getUserId(supabase: Awaited<ReturnType<typeof createClient>>) {
  if (!supabase) return DEMO_USER_ID;
  const { data: { user } } = await supabase.auth.getUser();
  return user?.id || DEMO_USER_ID;
}

// GET /api/mins/[id] - Get single MIN
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const supabase = await createClient();
    if (!supabase) {
      return NextResponse.json({ error: 'Database connection failed' }, { status: 500 });
    }

    const userId = await getUserId(supabase);

    const { data, error } = await supabase
      .from('mins')
      .select(`
        *,
        impact_projects:power_goals (
          id,
          title,
          category,
          visions (id, title, color)
        )
      `)
      .eq('id', id)
      .eq('user_id', userId)
      .single();

    if (error) {
      return NextResponse.json({ error: 'MIN not found' }, { status: 404 });
    }

    return NextResponse.json({ min: data });
  } catch (error) {
    console.error('GET /api/mins/[id] error:', error);
    return NextResponse.json({ error: 'Failed to fetch MIN' }, { status: 500 });
  }
}

// PUT /api/mins/[id] - Update MIN (including status changes)
export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const supabase = await createClient();
    if (!supabase) {
      return NextResponse.json({ error: 'Database connection failed' }, { status: 500 });
    }

    const userId = await getUserId(supabase);
    const body = await request.json();

    // Check if this is a completion action
    const isCompleting = body.status === 'completed';
    const wasAlreadyCompleted = body._wasCompleted; // Frontend can pass this

    const updateData: Record<string, unknown> = {
      updated_at: new Date().toISOString(),
    };

    // Map camelCase to snake_case
    const fieldMap: Record<string, string> = {
      title: 'title',
      description: 'description',
      scheduledDate: 'scheduled_date',
      scheduledTime: 'scheduled_time',
      durationMinutes: 'duration_minutes',
      priority: 'priority',
      timeScope: 'time_scope',
      weekStartDate: 'week_start_date',
      weekEndDate: 'week_end_date',
      valueQuadrant: 'drip_quadrant',
      makesMoneyScore: 'makes_money_score',
      energyScore: 'energy_score',
      impactProjectId: 'power_goal_id',
      status: 'status',
      isRecurring: 'is_recurring',
      recurrenceRule: 'recurrence_rule',
    };

    for (const [camel, snake] of Object.entries(fieldMap)) {
      if (body[camel] !== undefined) {
        updateData[snake] = body[camel];
      }
    }

    // Set completed_at timestamp
    if (isCompleting) {
      updateData.completed_at = new Date().toISOString();
    } else if (body.status === 'pending') {
      updateData.completed_at = null;
    }

    const { data, error } = await supabase
      .from('mins')
      .update(updateData)
      .eq('id', id)
      .eq('user_id', userId)
      .select(`
        *,
        impact_projects:power_goals (
          id,
          title,
          category,
          visions (id, title, color)
        )
      `)
      .single();

    if (error) {
      console.error('Error updating MIN:', error);
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    // Award XP if completing (and wasn't already completed)
    let gamificationResult = null;
    if (isCompleting && !wasAlreadyCompleted) {
      try {
        gamificationResult = await awardXp(userId, 'KPI_COMPLETED');
      } catch (xpError) {
        console.error('Failed to award XP:', xpError);
        // Don't fail the request for XP errors
      }
    }

    return NextResponse.json({
      min: data,
      gamification: gamificationResult,
    });
  } catch (error) {
    console.error('PUT /api/mins/[id] error:', error);
    return NextResponse.json({ error: 'Failed to update MIN' }, { status: 500 });
  }
}

// DELETE /api/mins/[id] - Delete MIN
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const supabase = await createClient();
    if (!supabase) {
      return NextResponse.json({ error: 'Database connection failed' }, { status: 500 });
    }

    const userId = await getUserId(supabase);

    const { error } = await supabase
      .from('mins')
      .delete()
      .eq('id', id)
      .eq('user_id', userId);

    if (error) {
      console.error('Error deleting MIN:', error);
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('DELETE /api/mins/[id] error:', error);
    return NextResponse.json({ error: 'Failed to delete MIN' }, { status: 500 });
  }
}
```

### Task 3: Create MINS React Query hooks
**File**: `src/lib/hooks/use-mins.ts` (new file)
**Action**: Create hooks for MINS CRUD operations

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

// Types
export interface Min {
  id: string;
  user_id: string;
  title: string;
  description: string | null;
  scheduled_date: string;
  scheduled_time: string | null;
  duration_minutes: number;
  priority: number;
  time_scope: 'daily' | 'weekly';
  week_start_date: string | null;
  week_end_date: string | null;
  drip_quadrant: string | null;
  makes_money_score: number | null;
  energy_score: number | null;
  power_goal_id: string | null;
  status: 'pending' | 'in_progress' | 'completed';
  completed_at: string | null;
  is_recurring: boolean;
  recurrence_rule: string | null;
  parent_min_id: string | null;
  created_at: string;
  updated_at: string;
  impact_projects?: {
    id: string;
    title: string;
    category: string | null;
    visions: {
      id: string;
      title: string;
      color: string | null;
    } | null;
  } | null;
}

export interface CreateMinInput {
  title: string;
  description?: string;
  scheduledDate: string;
  scheduledTime?: string;
  durationMinutes?: number;
  priority?: number;
  timeScope?: 'daily' | 'weekly';
  weekStartDate?: string;
  weekEndDate?: string;
  valueQuadrant?: string;
  makesMoneyScore?: number;
  energyScore?: number;
  impactProjectId?: string;
  isRecurring?: boolean;
  recurrenceRule?: string;
}

export interface UpdateMinInput extends Partial<CreateMinInput> {
  status?: 'pending' | 'in_progress' | 'completed';
  _wasCompleted?: boolean;
}

// Query keys
export const minsKeys = {
  all: ['mins'] as const,
  lists: () => [...minsKeys.all, 'list'] as const,
  list: (filters: { date?: string; timeScope?: string; status?: string; impactProjectId?: string }) =>
    [...minsKeys.lists(), filters] as const,
  details: () => [...minsKeys.all, 'detail'] as const,
  detail: (id: string) => [...minsKeys.details(), id] as const,
};

// Fetch functions
async function fetchMins(filters: { date?: string; timeScope?: string; status?: string; impactProjectId?: string }) {
  const params = new URLSearchParams();
  if (filters.date) params.set('date', filters.date);
  if (filters.timeScope) params.set('timeScope', filters.timeScope);
  if (filters.status) params.set('status', filters.status);
  if (filters.impactProjectId) params.set('impactProjectId', filters.impactProjectId);

  const response = await fetch(`/api/mins?${params.toString()}`);
  if (!response.ok) {
    throw new Error('Failed to fetch MINS');
  }
  const data = await response.json();
  return data.mins as Min[];
}

async function fetchMin(id: string) {
  const response = await fetch(`/api/mins/${id}`);
  if (!response.ok) {
    throw new Error('Failed to fetch MIN');
  }
  const data = await response.json();
  return data.min as Min;
}

async function createMin(input: CreateMinInput) {
  const response = await fetch('/api/mins', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(input),
  });
  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.error || 'Failed to create MIN');
  }
  const data = await response.json();
  return data.min as Min;
}

async function updateMin({ id, ...input }: UpdateMinInput & { id: string }) {
  const response = await fetch(`/api/mins/${id}`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(input),
  });
  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.error || 'Failed to update MIN');
  }
  return response.json();
}

async function deleteMin(id: string) {
  const response = await fetch(`/api/mins/${id}`, {
    method: 'DELETE',
  });
  if (!response.ok) {
    throw new Error('Failed to delete MIN');
  }
  return response.json();
}

// Hooks
export function useMins(filters: { date?: string; timeScope?: string; status?: string; impactProjectId?: string } = {}) {
  return useQuery({
    queryKey: minsKeys.list(filters),
    queryFn: () => fetchMins(filters),
    staleTime: 1000 * 60, // 1 minute
  });
}

export function useMin(id: string) {
  return useQuery({
    queryKey: minsKeys.detail(id),
    queryFn: () => fetchMin(id),
    enabled: !!id,
  });
}

export function useCreateMin() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: createMin,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: minsKeys.lists() });
    },
  });
}

export function useUpdateMin() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: updateMin,
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: minsKeys.lists() });
      queryClient.invalidateQueries({ queryKey: minsKeys.detail(variables.id) });
      // Also invalidate gamification stats if status changed to completed
      if (variables.status === 'completed') {
        queryClient.invalidateQueries({ queryKey: ['gamification'] });
      }
    },
  });
}

export function useDeleteMin() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: deleteMin,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: minsKeys.lists() });
    },
  });
}

export function useToggleMinComplete() {
  const updateMin = useUpdateMin();

  return {
    ...updateMin,
    mutate: (id: string, currentlyCompleted: boolean) => {
      updateMin.mutate({
        id,
        status: currentlyCompleted ? 'pending' : 'completed',
        _wasCompleted: currentlyCompleted,
      });
    },
    mutateAsync: async (id: string, currentlyCompleted: boolean) => {
      return updateMin.mutateAsync({
        id,
        status: currentlyCompleted ? 'pending' : 'completed',
        _wasCompleted: currentlyCompleted,
      });
    },
  };
}
```

### Task 4: Add MINS hooks to barrel export
**File**: `src/lib/hooks/index.ts`
**Action**: Export MINS hooks

Add to existing exports:
```typescript
export * from './use-mins';
```

### Task 5: Refactor MINS page to use real data
**File**: `src/app/(dashboard)/mins/page.tsx`
**Action**: Replace mock data with React Query hooks

Replace the entire file with database-connected implementation:
- Remove mockMins and mockImpactProjects arrays
- Import and use useMins, useCreateMin, useUpdateMin, useDeleteMin hooks
- Add loading and error states
- Keep existing UI components and layout
- Update handlers to use mutations

Key changes:
1. Replace `useState(mockMins)` with `useMins({ date: selectedDate.toISOString().split('T')[0] })`
2. Update handleAddMin to use `useCreateMin().mutate()`
3. Update handleToggleComplete to use `useToggleMinComplete().mutate()`
4. Update handleDeleteMin to use `useDeleteMin().mutate()`
5. Add loading spinner during data fetch
6. Add error boundary/toast for failures
7. Fetch real impact projects from API

### Task 6: Update MinForm to work with real API
**File**: `src/components/features/mins/min-form.tsx`
**Action**: Ensure form submits correct shape for API

Verify the form's onSubmit passes data matching CreateMinInput interface:
- scheduledDate (not scheduled_date)
- durationMinutes (not duration_minutes)
- valueQuadrant (not drip_quadrant)
- impactProjectId (not power_goal_id)

### Task 7: Add Impact Projects API hook for dropdown
**File**: `src/lib/hooks/use-impact-projects.ts` (new file if not exists)
**Action**: Create hook to fetch impact projects for MINS form dropdown

```typescript
import { useQuery } from '@tanstack/react-query';

export interface ImpactProject {
  id: string;
  title: string;
  category: string | null;
  vision_id: string;
  visions?: {
    title: string;
    color: string | null;
  };
}

export function useImpactProjects() {
  return useQuery({
    queryKey: ['impactProjects'],
    queryFn: async () => {
      const response = await fetch('/api/power-goals');
      if (!response.ok) throw new Error('Failed to fetch impact projects');
      const data = await response.json();
      return data.powerGoals as ImpactProject[];
    },
    staleTime: 1000 * 60 * 5, // 5 minutes
  });
}
```

## Verification

```bash
# Build check
npm run build

# Test the API endpoints manually:
# 1. GET /api/mins - should return empty array initially
# 2. POST /api/mins - create a test MIN
# 3. GET /api/mins - should now show the created MIN
# 4. PUT /api/mins/[id] - update status to completed
# 5. DELETE /api/mins/[id] - remove the test MIN

# Verify MINS page loads without errors
# Navigate to /mins in browser
```

## Success Criteria

- [ ] GET /api/mins returns list of MINS from database
- [ ] POST /api/mins creates new MINS in database
- [ ] PUT /api/mins/[id] updates MINS (including status)
- [ ] DELETE /api/mins/[id] removes MINS
- [ ] MINS page displays real data (no mock data)
- [ ] Create MIN form saves to database
- [ ] Toggle complete updates database and awards XP
- [ ] Impact Projects dropdown populated from API
- [ ] No TypeScript errors
- [ ] Build passes

## Output

- `src/app/api/mins/route.ts` - List and create endpoints
- `src/app/api/mins/[id]/route.ts` - Single MIN CRUD
- `src/lib/hooks/use-mins.ts` - React Query hooks
- `src/lib/hooks/use-impact-projects.ts` - Impact projects hook
- Updated `src/app/(dashboard)/mins/page.tsx` - Real data integration
- Updated `src/lib/hooks/index.ts` - Barrel exports
