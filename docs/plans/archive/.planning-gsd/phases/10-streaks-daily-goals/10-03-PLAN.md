# Plan 10-03: Daily Actions â†” MINS Bidirectional Sync

## Objective

Create bidirectional sync between Daily Actions (from vision plan) and MINS. Allow users to auto-populate MINS from their vision plan's daily actions, and sync completion status both ways. This ensures users have a single task management view in MINS while maintaining plan progress tracking.

## Execution Context

**Phase**: 10 - Streaks & Daily Goals
**Depends on**: Plan 10-01 (MINS API), Plan 10-02 (streak service)
**Scope**: ~350 lines across schema, API, and UI

**Reference files**:
- `src/lib/db/schema.ts` - mins and daily_actions tables
- `src/app/api/mins/route.ts` - MINS API from Plan 10-01
- `src/app/api/today/route.ts` - Daily actions API
- `src/app/(dashboard)/mins/page.tsx` - MINS page

## Context

**Current state**:
- `mins` table has no FK to `daily_actions`
- `daily_actions` are plan-generated, shown on Today dashboard
- MINS are user-created tasks
- No sync between the two systems

**Target state**:
- Optional FK link from mins to daily_actions
- API to generate MINS from today's daily actions
- Bidirectional completion sync
- UI to import daily actions as MINS

## Tasks

### Task 1: Add daily_action_id FK to mins table
**File**: `src/lib/db/schema.ts`
**Action**: Add optional foreign key to link MINS to daily actions

Add to the mins table definition (around line 340):
```typescript
// Link to daily action (for syncing from plan)
dailyActionId: uuid('daily_action_id').references(() => dailyActions.id, { onDelete: 'set null' }),
```

### Task 2: Generate and push schema migration
**Action**: Run Drizzle migration

```bash
npx drizzle-kit generate
npx drizzle-kit push
```

### Task 3: Create MINS import from daily actions API
**File**: `src/app/api/mins/import/route.ts` (new file)
**Action**: Bulk import today's daily actions as MINS

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';

const DEMO_USER_ID = '00000000-0000-0000-0000-000000000001';

async function getUserId(supabase: Awaited<ReturnType<typeof createClient>>) {
  if (!supabase) return DEMO_USER_ID;
  const { data: { user } } = await supabase.auth.getUser();
  return user?.id || DEMO_USER_ID;
}

// POST /api/mins/import - Import daily actions as MINS
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient();
    if (!supabase) {
      return NextResponse.json({ error: 'Database connection failed' }, { status: 500 });
    }

    const userId = await getUserId(supabase);
    const body = await request.json();

    const {
      date = new Date().toISOString().split('T')[0],
      actionIds, // Optional: specific action IDs to import, otherwise import all
    } = body;

    // Get daily actions for the date that don't already have linked MINS
    let query = supabase
      .from('daily_actions')
      .select(`
        id,
        title,
        description,
        action_date,
        estimated_minutes,
        scheduled_start_time,
        weekly_targets (
          monthly_targets (
            power_goals (
              id,
              title
            )
          )
        )
      `)
      .eq('user_id', userId)
      .eq('action_date', date)
      .neq('status', 'completed');

    if (actionIds && Array.isArray(actionIds) && actionIds.length > 0) {
      query = query.in('id', actionIds);
    }

    const { data: dailyActions, error: fetchError } = await query;

    if (fetchError) {
      return NextResponse.json({ error: fetchError.message }, { status: 500 });
    }

    if (!dailyActions || dailyActions.length === 0) {
      return NextResponse.json({
        imported: 0,
        message: 'No daily actions to import',
      });
    }

    // Check which actions already have linked MINS
    const { data: existingMins } = await supabase
      .from('mins')
      .select('daily_action_id')
      .eq('user_id', userId)
      .in('daily_action_id', dailyActions.map(a => a.id));

    const linkedActionIds = new Set(existingMins?.map(m => m.daily_action_id) || []);

    // Filter out actions that already have linked MINS
    const actionsToImport = dailyActions.filter(a => !linkedActionIds.has(a.id));

    if (actionsToImport.length === 0) {
      return NextResponse.json({
        imported: 0,
        message: 'All selected actions already have linked MINS',
      });
    }

    // Create MINS for each daily action
    const minsToCreate = actionsToImport.map((action) => ({
      user_id: userId,
      title: action.title,
      description: action.description,
      scheduled_date: action.action_date,
      scheduled_time: action.scheduled_start_time,
      duration_minutes: action.estimated_minutes || 30,
      priority: 1,
      time_scope: 'daily',
      power_goal_id: action.weekly_targets?.monthly_targets?.power_goals?.id || null,
      daily_action_id: action.id, // Link to source action
      status: 'pending',
    }));

    const { data: createdMins, error: createError } = await supabase
      .from('mins')
      .insert(minsToCreate)
      .select();

    if (createError) {
      return NextResponse.json({ error: createError.message }, { status: 500 });
    }

    return NextResponse.json({
      imported: createdMins?.length || 0,
      mins: createdMins,
      message: `Successfully imported ${createdMins?.length || 0} daily actions as MINS`,
    });
  } catch (error) {
    console.error('POST /api/mins/import error:', error);
    return NextResponse.json({ error: 'Failed to import daily actions' }, { status: 500 });
  }
}

// GET /api/mins/import - Get importable daily actions
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient();
    if (!supabase) {
      return NextResponse.json({ error: 'Database connection failed' }, { status: 500 });
    }

    const userId = await getUserId(supabase);
    const { searchParams } = new URL(request.url);
    const date = searchParams.get('date') || new Date().toISOString().split('T')[0];

    // Get daily actions for the date
    const { data: dailyActions, error: fetchError } = await supabase
      .from('daily_actions')
      .select(`
        id,
        title,
        description,
        action_date,
        estimated_minutes,
        status,
        weekly_targets (
          title,
          monthly_targets (
            title,
            power_goals (
              id,
              title,
              visions (title, color)
            )
          )
        )
      `)
      .eq('user_id', userId)
      .eq('action_date', date);

    if (fetchError) {
      return NextResponse.json({ error: fetchError.message }, { status: 500 });
    }

    // Check which already have linked MINS
    const actionIds = dailyActions?.map(a => a.id) || [];
    const { data: linkedMins } = await supabase
      .from('mins')
      .select('daily_action_id')
      .eq('user_id', userId)
      .in('daily_action_id', actionIds);

    const linkedActionIds = new Set(linkedMins?.map(m => m.daily_action_id) || []);

    // Mark which actions are already imported
    const actionsWithStatus = dailyActions?.map(action => ({
      ...action,
      isImported: linkedActionIds.has(action.id),
    })) || [];

    return NextResponse.json({
      date,
      actions: actionsWithStatus,
      importableCount: actionsWithStatus.filter(a => !a.isImported && a.status !== 'completed').length,
    });
  } catch (error) {
    console.error('GET /api/mins/import error:', error);
    return NextResponse.json({ error: 'Failed to fetch importable actions' }, { status: 500 });
  }
}
```

### Task 4: Create completion sync API
**File**: `src/app/api/mins/sync-completion/route.ts` (new file)
**Action**: Sync completion status between linked MINS and daily actions

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { updateUserDailyStreak } from '@/lib/services/streaks';
import { awardXp } from '@/lib/services/gamification';

const DEMO_USER_ID = '00000000-0000-0000-0000-000000000001';

async function getUserId(supabase: Awaited<ReturnType<typeof createClient>>) {
  if (!supabase) return DEMO_USER_ID;
  const { data: { user } } = await supabase.auth.getUser();
  return user?.id || DEMO_USER_ID;
}

// POST /api/mins/sync-completion - Sync MIN completion to linked daily action
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient();
    if (!supabase) {
      return NextResponse.json({ error: 'Database connection failed' }, { status: 500 });
    }

    const userId = await getUserId(supabase);
    const body = await request.json();

    const { minId, completed } = body;

    if (!minId || completed === undefined) {
      return NextResponse.json(
        { error: 'minId and completed status are required' },
        { status: 400 }
      );
    }

    // Get the MIN with its linked daily action
    const { data: min, error: minError } = await supabase
      .from('mins')
      .select('id, daily_action_id, status')
      .eq('id', minId)
      .eq('user_id', userId)
      .single();

    if (minError || !min) {
      return NextResponse.json({ error: 'MIN not found' }, { status: 404 });
    }

    const now = new Date().toISOString();
    const wasCompleted = min.status === 'completed';

    // Update MIN status
    const { error: updateMinError } = await supabase
      .from('mins')
      .update({
        status: completed ? 'completed' : 'pending',
        completed_at: completed ? now : null,
        updated_at: now,
      })
      .eq('id', minId);

    if (updateMinError) {
      return NextResponse.json({ error: 'Failed to update MIN' }, { status: 500 });
    }

    // If linked to daily action, sync the status
    let dailyActionUpdated = false;
    if (min.daily_action_id) {
      const { error: updateActionError } = await supabase
        .from('daily_actions')
        .update({
          status: completed ? 'completed' : 'pending',
          completed_at: completed ? now : null,
          updated_at: now,
        })
        .eq('id', min.daily_action_id)
        .eq('user_id', userId);

      if (!updateActionError) {
        dailyActionUpdated = true;
      }
    }

    // Award XP and update streak if completing (not uncompleting)
    let gamificationResult = null;
    if (completed && !wasCompleted) {
      try {
        gamificationResult = await awardXp(userId, 'KPI_COMPLETED');
        await updateUserDailyStreak(userId);
      } catch (xpError) {
        console.error('Failed to award XP:', xpError);
      }
    }

    return NextResponse.json({
      success: true,
      minUpdated: true,
      dailyActionUpdated,
      gamification: gamificationResult,
    });
  } catch (error) {
    console.error('POST /api/mins/sync-completion error:', error);
    return NextResponse.json({ error: 'Failed to sync completion' }, { status: 500 });
  }
}
```

### Task 5: Add import hook to use-mins.ts
**File**: `src/lib/hooks/use-mins.ts`
**Action**: Add hooks for importing daily actions

Add to existing file:
```typescript
// Fetch importable daily actions
export function useImportableDailyActions(date: string) {
  return useQuery({
    queryKey: ['mins', 'importable', date],
    queryFn: async () => {
      const response = await fetch(`/api/mins/import?date=${date}`);
      if (!response.ok) throw new Error('Failed to fetch importable actions');
      return response.json();
    },
  });
}

// Import daily actions as MINS
export function useImportDailyActions() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ date, actionIds }: { date?: string; actionIds?: string[] }) => {
      const response = await fetch('/api/mins/import', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ date, actionIds }),
      });
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to import daily actions');
      }
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: minsKeys.lists() });
      queryClient.invalidateQueries({ queryKey: ['mins', 'importable'] });
    },
  });
}

// Sync completion with linked daily action
export function useSyncMinCompletion() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ minId, completed }: { minId: string; completed: boolean }) => {
      const response = await fetch('/api/mins/sync-completion', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ minId, completed }),
      });
      if (!response.ok) {
        throw new Error('Failed to sync completion');
      }
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: minsKeys.lists() });
      queryClient.invalidateQueries({ queryKey: ['today'] });
      queryClient.invalidateQueries({ queryKey: ['gamification'] });
    },
  });
}
```

### Task 6: Add import UI to MINS page
**File**: `src/app/(dashboard)/mins/page.tsx`
**Action**: Add "Import from Plan" button and dialog

Add an import button to the Quick Add card section:
```typescript
// Add to imports
import { useImportableDailyActions, useImportDailyActions } from '@/lib/hooks/use-mins';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from '@/components/ui/dialog';
import { Download, Check } from 'lucide-react';

// Add state for import dialog
const [isImportOpen, setIsImportOpen] = useState(false);
const dateStr = selectedDate.toISOString().split('T')[0];
const { data: importableData, isLoading: importLoading } = useImportableDailyActions(dateStr);
const importMutation = useImportDailyActions();

// Add import handler
const handleImportAll = async () => {
  try {
    await importMutation.mutateAsync({ date: dateStr });
    toast.success('Daily actions imported as MINS');
    setIsImportOpen(false);
  } catch (error) {
    toast.error('Failed to import daily actions');
  }
};

// Add to Quick Add card:
<Button
  variant="outline"
  className="w-full justify-start"
  onClick={() => setIsImportOpen(true)}
>
  <Download className="h-4 w-4 mr-2" />
  Import from Plan
  {importableData?.importableCount > 0 && (
    <Badge variant="secondary" className="ml-auto">
      {importableData.importableCount}
    </Badge>
  )}
</Button>

// Add import dialog:
<Dialog open={isImportOpen} onOpenChange={setIsImportOpen}>
  <DialogContent>
    <DialogHeader>
      <DialogTitle>Import Daily Actions</DialogTitle>
      <DialogDescription>
        Import your planned daily actions as MINS for {formatDate(selectedDate)}
      </DialogDescription>
    </DialogHeader>
    <div className="space-y-4 py-4">
      {importLoading ? (
        <div className="text-center py-4">Loading...</div>
      ) : importableData?.actions?.length > 0 ? (
        <>
          <div className="space-y-2 max-h-64 overflow-y-auto">
            {importableData.actions.map((action) => (
              <div
                key={action.id}
                className={cn(
                  'p-3 border rounded-lg',
                  action.isImported && 'opacity-50'
                )}
              >
                <div className="flex items-center justify-between">
                  <span className="font-medium">{action.title}</span>
                  {action.isImported && (
                    <Badge variant="secondary">
                      <Check className="h-3 w-3 mr-1" />
                      Imported
                    </Badge>
                  )}
                </div>
                {action.weekly_targets?.monthly_targets?.power_goals?.title && (
                  <p className="text-xs text-muted-foreground mt-1">
                    {action.weekly_targets.monthly_targets.power_goals.title}
                  </p>
                )}
              </div>
            ))}
          </div>
          <Button
            onClick={handleImportAll}
            disabled={importableData.importableCount === 0 || importMutation.isPending}
            className="w-full"
          >
            {importMutation.isPending ? 'Importing...' : `Import ${importableData.importableCount} Actions`}
          </Button>
        </>
      ) : (
        <p className="text-center text-muted-foreground py-4">
          No daily actions available for this date
        </p>
      )}
    </div>
  </DialogContent>
</Dialog>
```

### Task 7: Update MINS completion to use sync API
**File**: `src/app/(dashboard)/mins/page.tsx`
**Action**: Use useSyncMinCompletion for linked items

Update the toggle complete handler to use sync API when MIN has linked daily action:
```typescript
const syncCompletion = useSyncMinCompletion();

const handleToggleComplete = async (min: Min, completed: boolean) => {
  if (min.daily_action_id) {
    // Use sync API for linked items
    await syncCompletion.mutateAsync({ minId: min.id, completed });
  } else {
    // Use regular update for standalone MINS
    await updateMin.mutateAsync({
      id: min.id,
      status: completed ? 'completed' : 'pending',
      _wasCompleted: !completed,
    });
  }
};
```

## Verification

```bash
# Build check
npm run build

# Push schema changes
npx drizzle-kit push

# Test flow:
# 1. Create some daily actions in a vision plan
# 2. Go to MINS page
# 3. Click "Import from Plan"
# 4. Import daily actions
# 5. Complete a MIN that has linked daily action
# 6. Check Today page - daily action should also be completed
```

## Success Criteria

- [ ] mins table has daily_action_id FK column
- [ ] Import API creates MINS from daily actions with link
- [ ] GET /api/mins/import shows which actions are already imported
- [ ] Completing linked MIN also completes daily action
- [ ] Import dialog shows available actions
- [ ] Already imported actions show as such
- [ ] XP awarded only once for linked completion
- [ ] No TypeScript errors
- [ ] Build passes

## Output

- Updated `src/lib/db/schema.ts` - daily_action_id FK
- `src/app/api/mins/import/route.ts` - Import API
- `src/app/api/mins/sync-completion/route.ts` - Completion sync API
- Updated `src/lib/hooks/use-mins.ts` - Import and sync hooks
- Updated `src/app/(dashboard)/mins/page.tsx` - Import UI
- New migration file for FK column
