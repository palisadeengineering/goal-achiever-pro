---
phase: 04-frontend-state
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/hooks/use-goal-tree.ts
  - src/lib/hooks/use-kpi-mutations.ts
  - src/lib/hooks/index.ts
autonomous: true

must_haves:
  truths:
    - "useGoalTree hook fetches and returns nested KPI hierarchy for a vision"
    - "useLogKpi mutation posts log and returns updated ancestor progress"
    - "Optimistic update shows new progress before server confirms"
    - "Failed mutation rolls back to previous state"
    - "Error message is accessible from mutation state"
  artifacts:
    - path: "src/lib/hooks/use-goal-tree.ts"
      provides: "React Query hook for goal tree fetching"
      exports: ["useGoalTree"]
    - path: "src/lib/hooks/use-kpi-mutations.ts"
      provides: "React Query mutations with optimistic updates"
      exports: ["useLogKpi", "useOverrideProgress"]
    - path: "src/lib/hooks/index.ts"
      provides: "Barrel export for hooks"
      contains: "useGoalTree"
  key_links:
    - from: "src/lib/hooks/use-goal-tree.ts"
      to: "/api/goal-tree/{visionId}"
      via: "fetch in queryFn"
      pattern: "fetch.*api/goal-tree"
    - from: "src/lib/hooks/use-kpi-mutations.ts"
      to: "/api/vision-kpis/{id}/log"
      via: "fetch in mutationFn"
      pattern: "fetch.*api/vision-kpis"
---

<objective>
Create React Query hooks for goal tree fetching and KPI mutations with optimistic updates.

Purpose: Provide instant UI feedback when users complete KPIs by optimistically updating progress before server confirms, with rollback on error.

Output: Two new hook files (use-goal-tree.ts, use-kpi-mutations.ts) and updated barrel export.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# API endpoints from Phase 3
@src/app/api/goal-tree/[visionId]/route.ts
@src/app/api/vision-kpis/[id]/log/route.ts

# Types from progress library
@src/lib/progress/tree.ts
@src/lib/progress/types.ts
@src/lib/progress/ancestor-rollup.ts

# Existing React Query patterns
@src/app/(dashboard)/goals/page.tsx
@src/components/providers.tsx

# Existing hooks directory structure
@src/lib/hooks/use-time-blocks.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useGoalTree hook</name>
  <files>src/lib/hooks/use-goal-tree.ts</files>
  <action>
Create a new React Query hook for fetching the goal tree hierarchy.

The hook must:
1. Accept visionId as parameter (string)
2. Use useQuery from @tanstack/react-query
3. Return the goal tree API response shape: { visionId, tree: KpiTreeNode[], metadata }
4. Handle loading, error, and refetch states
5. Use query key pattern: ['goalTree', visionId]
6. Include enabled option to skip fetching when visionId is undefined/empty

Type imports:
- Import KpiTreeNode from '@/lib/progress'

Response type (match API):
```typescript
interface GoalTreeResponse {
  visionId: string;
  tree: KpiTreeNode[];
  metadata: {
    totalKpis: number;
    lastCalculated: string | null;
    duration: number;
  };
}
```

Hook signature:
```typescript
export function useGoalTree(visionId: string | undefined) {
  // Returns UseQueryResult<GoalTreeResponse, Error>
}
```

Follow the pattern from use-time-blocks.ts but use React Query instead of useState for data management.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
File exists with correct exports: `grep -l "useGoalTree" src/lib/hooks/use-goal-tree.ts`
  </verify>
  <done>
useGoalTree hook exported and compiles. Takes visionId, returns query result with tree data.
  </done>
</task>

<task type="auto">
  <name>Task 2a: Create useLogKpi mutation with optimistic updates</name>
  <files>src/lib/hooks/use-kpi-mutations.ts</files>
  <action>
Create React Query mutation for KPI logging with optimistic updates.

The hook must:
1. Use useMutation from @tanstack/react-query
2. Implement optimistic update in onMutate:
   - Snapshot previous tree state using queryClient.getQueryData
   - Optimistically update ONLY the logged KPI node to 100% progress (NOT ancestors)
   - Update cache with queryClient.setQueryData
3. Implement rollback in onError:
   - Restore snapshot on failure
4. Implement cache sync in onSettled:
   - Invalidate tree query to trigger refetch with accurate ancestor rollup from server
5. Accept callbacks: onSuccess, onError

Type imports:
- Import AncestorProgressUpdate from '@/lib/progress'
- Import KpiTreeNode from '@/lib/progress'

Log API request type:
```typescript
interface LogKpiRequest {
  kpiId: string;
  date?: string;
  value?: number;
  isCompleted?: boolean;
  notes?: string;
}
```

Log API response type (from 03-02):
```typescript
interface LogKpiResponse {
  log: {
    id: string;
    kpi_id: string;
    log_date: string;
    value: number | null;
    is_completed: boolean;
    notes: string | null;
  };
  rollup: {
    updatedKpis: AncestorProgressUpdate[];
    duration: number;
  };
}
```

Hook signature:
```typescript
export function useLogKpi(visionId: string | undefined) {
  // Returns UseMutationResult with optimistic updates
}
```

Optimistic update strategy (simple, immediate feedback):
```typescript
onMutate: async (variables: LogKpiRequest) => {
  // 1. Cancel outgoing refetches
  await queryClient.cancelQueries({ queryKey: ['goalTree', visionId] });

  // 2. Snapshot previous state for rollback
  const previousTree = queryClient.getQueryData(['goalTree', visionId]);

  // 3. Optimistically update ONLY the logged KPI (not ancestors)
  queryClient.setQueryData(['goalTree', visionId], (old: GoalTreeResponse | undefined) => {
    if (!old) return old;
    return updateSingleKpiProgress(old, variables.kpiId, variables.isCompleted ? 100 : 0);
  });

  // 4. Return context for rollback
  return { previousTree };
}

onError: (err, variables, context) => {
  // Rollback to snapshot
  if (context?.previousTree) {
    queryClient.setQueryData(['goalTree', visionId], context.previousTree);
  }
}

onSettled: () => {
  // Refetch to get accurate ancestor rollup from server
  queryClient.invalidateQueries({ queryKey: ['goalTree', visionId] });
}
```

Helper function to add (simple, single-node update):
```typescript
function updateSingleKpiProgress(
  response: GoalTreeResponse,
  kpiId: string,
  newProgress: number
): GoalTreeResponse {
  const cloned = structuredClone(response.tree);

  function findAndUpdate(nodes: KpiTreeNode[]): boolean {
    for (const node of nodes) {
      if (node.id === kpiId) {
        node.progress = newProgress;
        return true;
      }
      if (node.children && findAndUpdate(node.children)) return true;
    }
    return false;
  }

  findAndUpdate(cloned);
  return { ...response, tree: cloned };
}
```
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
File exports useLogKpi: `grep "export function useLogKpi" src/lib/hooks/use-kpi-mutations.ts`
  </verify>
  <done>
useLogKpi hook exported. Mutation optimistically updates single KPI, rolls back on error, and refetches for accurate ancestor progress.
  </done>
</task>

<task type="auto">
  <name>Task 2b: Create useOverrideProgress mutation</name>
  <files>src/lib/hooks/use-kpi-mutations.ts</files>
  <action>
Add useOverrideProgress hook to the same file for manual progress overrides.

The hook must:
1. Use useMutation from @tanstack/react-query
2. POST to /api/kpi-progress/{id}/override
3. Implement same optimistic pattern as useLogKpi

Override API request type:
```typescript
interface OverrideProgressRequest {
  kpiId: string;
  progress: number;  // 0-100
  reason?: string;
}
```

Hook signature:
```typescript
export function useOverrideProgress(visionId: string | undefined) {
  // Returns UseMutationResult with optimistic updates
}
```

Implementation mirrors useLogKpi but:
- POSTs to different endpoint (/api/kpi-progress/{id}/override)
- Uses the provided progress value directly instead of 100%

```typescript
export function useOverrideProgress(visionId: string | undefined) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (req: OverrideProgressRequest) => {
      const response = await fetch(`/api/kpi-progress/${req.kpiId}/override`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ progress: req.progress, reason: req.reason }),
      });
      if (!response.ok) throw new Error('Failed to override progress');
      return response.json();
    },
    onMutate: async (variables) => {
      await queryClient.cancelQueries({ queryKey: ['goalTree', visionId] });
      const previousTree = queryClient.getQueryData(['goalTree', visionId]);
      queryClient.setQueryData(['goalTree', visionId], (old: GoalTreeResponse | undefined) => {
        if (!old) return old;
        return updateSingleKpiProgress(old, variables.kpiId, variables.progress);
      });
      return { previousTree };
    },
    onError: (err, variables, context) => {
      if (context?.previousTree) {
        queryClient.setQueryData(['goalTree', visionId], context.previousTree);
      }
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ['goalTree', visionId] });
    },
  });
}
```
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
File exports useOverrideProgress: `grep "export function useOverrideProgress" src/lib/hooks/use-kpi-mutations.ts`
  </verify>
  <done>
useOverrideProgress hook exported. Mutation allows manual progress override with same optimistic pattern as useLogKpi.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update hooks barrel export</name>
  <files>src/lib/hooks/index.ts</files>
  <action>
Create or update the hooks barrel export file to include new goal tree hooks.

Add exports:
```typescript
export { useGoalTree } from './use-goal-tree';
export { useLogKpi, useOverrideProgress } from './use-kpi-mutations';
```

If index.ts doesn't exist, create it with all hook exports.
If it exists, add the new exports while preserving existing ones.

Check what already exists:
- If no index.ts, create with exports for use-goal-tree and use-kpi-mutations only (other hooks may have their own import patterns)
  </action>
  <verify>
File exists: `ls src/lib/hooks/index.ts`
Exports new hooks: `grep -E "useGoalTree|useLogKpi" src/lib/hooks/index.ts`
  </verify>
  <done>
Barrel export file exists and exports useGoalTree, useLogKpi, useOverrideProgress.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. New files exist:
   - src/lib/hooks/use-goal-tree.ts
   - src/lib/hooks/use-kpi-mutations.ts
   - src/lib/hooks/index.ts (or updated)
3. Exports are correct:
   - `grep "useGoalTree" src/lib/hooks/use-goal-tree.ts`
   - `grep "useLogKpi" src/lib/hooks/use-kpi-mutations.ts`
</verification>

<success_criteria>
1. useGoalTree hook fetches goal tree from /api/goal-tree/{visionId}
2. useLogKpi mutation posts to /api/vision-kpis/{id}/log with optimistic updates
3. Failed mutations roll back cache to previous state
4. Error state accessible from mutation result
5. All files compile with TypeScript
</success_criteria>

<output>
After completion, create `.planning/phases/04-frontend-state/04-01-SUMMARY.md`
</output>
