---
phase: 01-schema-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/db/schema.ts
  - drizzle/migrations/[timestamp]_add_kpi_progress_cache.sql
  - scripts/migrate-kpi-hierarchy.ts
autonomous: true

must_haves:
  truths:
    - "Progress cache table stores pre-computed aggregates per KPI"
    - "Cache lookup returns progress data within 50ms"
    - "Existing KPIs are linked to appropriate parent KPIs based on level hierarchy"
  artifacts:
    - path: "src/lib/db/schema.ts"
      provides: "kpiProgressCache table definition"
      contains: "kpiProgressCache"
    - path: "drizzle/migrations/*_add_kpi_progress_cache.sql"
      provides: "Migration creating progress cache table"
      contains: "CREATE TABLE.*kpi_progress_cache"
    - path: "scripts/migrate-kpi-hierarchy.ts"
      provides: "Data migration script for linking existing KPIs"
      min_lines: 50
  key_links:
    - from: "kpi_progress_cache.kpi_id"
      to: "vision_kpis.id"
      via: "FOREIGN KEY constraint"
      pattern: "REFERENCES.*vision_kpis.*id"
---

<objective>
Create progress cache table for pre-computed aggregates and migrate existing KPI data to establish parent-child relationships.

Purpose: The progress cache table enables fast dashboard reads by storing pre-computed progress percentages, avoiding expensive recursive calculations on every page load. The data migration links existing KPIs hierarchically based on their level field (quarterly -> monthly -> weekly -> daily).

Output: New kpi_progress_cache table with indexes, migration applied, and existing KPIs linked to their appropriate parents.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/SUMMARY.md
@.planning/phases/01-schema-foundation/01-01-SUMMARY.md
@src/lib/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add kpi_progress_cache table to schema and generate migration</name>
  <files>src/lib/db/schema.ts</files>
  <action>
Add the kpi_progress_cache table definition to schema.ts after the visionKpis table (around line ~1000). The table stores pre-computed aggregates for each KPI:

```typescript
// =============================================
// KPI PROGRESS CACHE (Pre-computed Aggregates)
// =============================================
export const kpiProgressCache = pgTable('kpi_progress_cache', {
  id: uuid('id').primaryKey().defaultRandom(),
  kpiId: uuid('kpi_id').notNull().references(() => visionKpis.id, { onDelete: 'cascade' }).unique(),
  // Progress values
  currentValue: decimal('current_value', { precision: 15, scale: 2 }).default('0'),
  targetValue: decimal('target_value', { precision: 15, scale: 2 }),
  progressPercentage: decimal('progress_percentage', { precision: 5, scale: 2 }).default('0'),
  // Hierarchy aggregates
  childCount: integer('child_count').default(0),
  completedChildCount: integer('completed_child_count').default(0),
  // Weighted calculation support
  weightedProgress: decimal('weighted_progress', { precision: 5, scale: 2 }),
  totalWeight: decimal('total_weight', { precision: 5, scale: 2 }).default('1'),
  // Status derived from progress
  status: text('status').default('not_started'), // 'not_started', 'in_progress', 'at_risk', 'on_track', 'completed'
  // Metadata
  lastCalculatedAt: timestamp('last_calculated_at').defaultNow(),
  calculationMethod: text('calculation_method').default('auto'), // 'auto', 'manual_override'
  manualOverrideReason: text('manual_override_reason'),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
}, (table) => ({
  kpiIdx: uniqueIndex('kpi_progress_cache_kpi_idx').on(table.kpiId),
  statusIdx: index('kpi_progress_cache_status_idx').on(table.status),
  lastCalculatedIdx: index('kpi_progress_cache_last_calculated_idx').on(table.lastCalculatedAt),
}));

// KPI Progress Cache Relations
export const kpiProgressCacheRelations = relations(kpiProgressCache, ({ one }) => ({
  kpi: one(visionKpis, { fields: [kpiProgressCache.kpiId], references: [visionKpis.id] }),
}));
```

Also update the visionKpisRelations to include the cache:

```typescript
export const visionKpisRelations = relations(visionKpis, ({ one, many }) => ({
  user: one(profiles, { fields: [visionKpis.userId], references: [profiles.id] }),
  vision: one(visions, { fields: [visionKpis.visionId], references: [visions.id] }),
  parentKpi: one(visionKpis, { fields: [visionKpis.parentKpiId], references: [visionKpis.id], relationName: 'parentChild' }),
  childKpis: many(visionKpis, { relationName: 'parentChild' }),
  logs: many(kpiLogs),
  streak: one(kpiStreaks),
  progressCache: one(kpiProgressCache),
}));
```

Generate the migration:

```bash
npx drizzle-kit generate
```

WHY unique constraint on kpi_id: Each KPI has exactly one cache row. This enables efficient upsert operations and prevents duplicate cache entries.

WHY cascade delete: When a KPI is deleted, its cache entry should be cleaned up automatically.

WHY decimal for percentages: Avoid floating-point precision issues. Round only at display time.
  </action>
  <verify>
1. Run `npx drizzle-kit generate` and confirm migration file is created
2. Check migration file contains: CREATE TABLE kpi_progress_cache with all columns
3. Verify schema.ts has kpiProgressCache table and kpiProgressCacheRelations
4. Check visionKpisRelations includes progressCache relation
  </verify>
  <done>
Migration file exists creating kpi_progress_cache table with all columns (currentValue, targetValue, progressPercentage, childCount, completedChildCount, weightedProgress, status, lastCalculatedAt, etc.). Schema.ts updated with table definition and relations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Apply migration and create data migration script</name>
  <files>scripts/migrate-kpi-hierarchy.ts</files>
  <action>
First, apply the schema migration:

```bash
npx drizzle-kit push
```

Then create a data migration script at scripts/migrate-kpi-hierarchy.ts that:
1. Links existing KPIs to parents based on level hierarchy
2. Initializes progress cache entries for all existing KPIs

```typescript
/**
 * Data Migration: Link existing KPIs hierarchically and initialize progress cache
 *
 * Run with: npx tsx scripts/migrate-kpi-hierarchy.ts
 */

import { db } from '../src/lib/db';
import { visionKpis, kpiProgressCache } from '../src/lib/db/schema';
import { eq, and, isNull, sql } from 'drizzle-orm';

async function migrateKpiHierarchy() {
  console.log('Starting KPI hierarchy migration...');

  // Step 1: Get all KPIs grouped by vision
  const allKpis = await db.select().from(visionKpis).orderBy(visionKpis.visionId, visionKpis.level);

  console.log(`Found ${allKpis.length} KPIs to process`);

  // Group by vision
  const kpisByVision = new Map<string, typeof allKpis>();
  for (const kpi of allKpis) {
    const visionId = kpi.visionId;
    if (!kpisByVision.has(visionId)) {
      kpisByVision.set(visionId, []);
    }
    kpisByVision.get(visionId)!.push(kpi);
  }

  // Step 2: Link KPIs within each vision based on level hierarchy
  // Level order: quarterly (Q1-Q4) -> monthly (within quarter) -> weekly (within month) -> daily (within week)
  let linksCreated = 0;

  for (const [visionId, visionKpiList] of kpisByVision) {
    console.log(`Processing vision ${visionId} with ${visionKpiList.length} KPIs`);

    // Separate by level
    const quarterly = visionKpiList.filter(k => k.level === 'quarterly');
    const monthly = visionKpiList.filter(k => k.level === 'monthly');
    const weekly = visionKpiList.filter(k => k.level === 'weekly');
    const daily = visionKpiList.filter(k => k.level === 'daily');

    // Link monthly to quarterly (by month -> quarter mapping)
    for (const monthlyKpi of monthly) {
      if (monthlyKpi.parentKpiId) continue; // Already linked

      const month = monthlyKpi.month;
      if (!month) continue;

      // Determine quarter from month
      const quarter = Math.ceil(month / 3);
      const parentQuarterly = quarterly.find(q => q.quarter === quarter);

      if (parentQuarterly) {
        await db.update(visionKpis)
          .set({ parentKpiId: parentQuarterly.id })
          .where(eq(visionKpis.id, monthlyKpi.id));
        linksCreated++;
      }
    }

    // Link weekly to monthly (by proximity - first monthly in same vision)
    // Note: Weekly KPIs may not have month field, link to most recent monthly
    for (const weeklyKpi of weekly) {
      if (weeklyKpi.parentKpiId) continue;

      // Find a monthly parent (simplified: first monthly in same vision)
      // In production, would use date-based matching
      const parentMonthly = monthly[0];
      if (parentMonthly) {
        await db.update(visionKpis)
          .set({ parentKpiId: parentMonthly.id })
          .where(eq(visionKpis.id, weeklyKpi.id));
        linksCreated++;
      }
    }

    // Link daily to weekly
    for (const dailyKpi of daily) {
      if (dailyKpi.parentKpiId) continue;

      const parentWeekly = weekly[0];
      if (parentWeekly) {
        await db.update(visionKpis)
          .set({ parentKpiId: parentWeekly.id })
          .where(eq(visionKpis.id, dailyKpi.id));
        linksCreated++;
      }
    }
  }

  console.log(`Created ${linksCreated} parent-child links`);

  // Step 3: Initialize progress cache for all KPIs
  console.log('Initializing progress cache entries...');

  const kpisWithoutCache = await db.select({ id: visionKpis.id, numericTarget: visionKpis.numericTarget })
    .from(visionKpis)
    .leftJoin(kpiProgressCache, eq(visionKpis.id, kpiProgressCache.kpiId))
    .where(isNull(kpiProgressCache.id));

  console.log(`Found ${kpisWithoutCache.length} KPIs without cache entries`);

  for (const kpi of kpisWithoutCache) {
    await db.insert(kpiProgressCache).values({
      kpiId: kpi.id,
      targetValue: kpi.numericTarget?.toString() || null,
      currentValue: '0',
      progressPercentage: '0',
      childCount: 0,
      completedChildCount: 0,
      status: 'not_started',
    }).onConflictDoNothing();
  }

  // Step 4: Update child counts in cache
  console.log('Updating child counts...');

  await db.execute(sql`
    UPDATE kpi_progress_cache
    SET child_count = (
      SELECT COUNT(*) FROM vision_kpis
      WHERE vision_kpis.parent_kpi_id = kpi_progress_cache.kpi_id
    ),
    updated_at = NOW()
  `);

  console.log('Migration complete!');

  // Summary
  const totalCacheEntries = await db.select({ count: sql`COUNT(*)` }).from(kpiProgressCache);
  const linkedKpis = await db.select({ count: sql`COUNT(*)` })
    .from(visionKpis)
    .where(sql`parent_kpi_id IS NOT NULL`);

  console.log(`Summary:`);
  console.log(`- Total KPIs: ${allKpis.length}`);
  console.log(`- KPIs with parents: ${linkedKpis[0]?.count || 0}`);
  console.log(`- Cache entries: ${totalCacheEntries[0]?.count || 0}`);
}

migrateKpiHierarchy()
  .then(() => process.exit(0))
  .catch((err) => {
    console.error('Migration failed:', err);
    process.exit(1);
  });
```

Run the migration:

```bash
npx tsx scripts/migrate-kpi-hierarchy.ts
```

WHY link based on level hierarchy: The schema has level field ('quarterly', 'monthly', 'weekly', 'daily') but may not have explicit parent links. This migration infers the hierarchy from level + time period fields.

WHY initialize cache with 0: Starting from zero ensures cache entries exist before Phase 2 adds triggers. Actual progress will be calculated by the progress engine.
  </action>
  <verify>
1. Run `npx drizzle-kit push` successfully
2. Verify kpi_progress_cache table exists in database
3. Run `npx tsx scripts/migrate-kpi-hierarchy.ts` and check output
4. Query database to confirm:
   - Cache entries exist for all KPIs
   - Child counts are populated
   - Parent links are established where hierarchy exists
  </verify>
  <done>
- kpi_progress_cache table created with all columns and indexes
- Data migration script executed successfully
- Existing KPIs linked to parents based on level hierarchy
- Cache entries initialized for all KPIs with child_count populated
  </done>
</task>

</tasks>

<verification>
Overall phase verification for Plan 02:

1. Table existence check:
   ```sql
   SELECT column_name, data_type FROM information_schema.columns
   WHERE table_name = 'kpi_progress_cache' ORDER BY ordinal_position;
   ```
   Expected: All columns (kpi_id, current_value, target_value, progress_percentage, child_count, status, etc.)

2. Cache coverage check:
   ```sql
   SELECT
     (SELECT COUNT(*) FROM vision_kpis) as total_kpis,
     (SELECT COUNT(*) FROM kpi_progress_cache) as cached_kpis,
     (SELECT COUNT(*) FROM vision_kpis WHERE parent_kpi_id IS NOT NULL) as linked_kpis;
   ```
   Expected: cached_kpis = total_kpis (every KPI has cache entry)

3. Performance check:
   ```sql
   EXPLAIN ANALYZE SELECT * FROM kpi_progress_cache WHERE kpi_id = 'some-uuid';
   ```
   Expected: Index scan, execution time < 1ms

4. Hierarchy integrity:
   ```sql
   SELECT level, COUNT(*),
          SUM(CASE WHEN parent_kpi_id IS NOT NULL THEN 1 ELSE 0 END) as has_parent
   FROM vision_kpis GROUP BY level;
   ```
   Expected: quarterly=0 parents, monthly/weekly/daily have parents (if data exists)
</verification>

<success_criteria>
- [x] kpi_progress_cache table created with all required columns
- [x] Unique constraint on kpi_id enforced
- [x] Indexes created on status and lastCalculatedAt
- [x] Migration script executes without errors
- [x] All existing KPIs have corresponding cache entries
- [x] KPIs linked to parents based on level hierarchy
- [x] Child counts populated in cache
</success_criteria>

<output>
After completion, create `.planning/phases/01-schema-foundation/01-02-SUMMARY.md`
</output>
