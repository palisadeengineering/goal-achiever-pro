---
phase: 05-cascade-generation
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - src/app/api/visions/[id]/generate-cascade/route.ts
  - src/lib/hooks/use-cascade-generation.ts
  - src/lib/hooks/index.ts
autonomous: true

must_haves:
  truths:
    - "Re-generating cascade adds new items without deleting existing KPIs"
    - "User's manually created KPIs are preserved after regeneration"
    - "Existing progress data is not lost"
    - "Frontend can trigger incremental generation"
  artifacts:
    - path: "src/app/api/visions/[id]/generate-cascade/route.ts"
      provides: "Incremental mode support via mode param in body"
      contains: "mode.*incremental"
    - path: "src/lib/hooks/use-cascade-generation.ts"
      provides: "useGenerateCascade mutation hook"
      exports: ["useGenerateCascade"]
  key_links:
    - from: "src/lib/hooks/use-cascade-generation.ts"
      to: "/api/visions/[id]/generate-cascade"
      via: "fetch POST"
      pattern: "fetch.*generate-cascade"
    - from: "src/app/api/visions/[id]/generate-cascade/route.ts"
      to: "vision_kpis table"
      via: "check existing before insert"
      pattern: "existing.*kpis|mode.*incremental"
---

<objective>
Add incremental generation mode that preserves existing KPIs when regenerating cascade.

Purpose: When a user runs cascade generation again (maybe they updated their vision SMART goals), we should:
1. Preserve all existing KPIs they've customized or manually created
2. Only add NEW generated items that don't conflict
3. Never delete user data or progress

**Dependencies:**
- Depends on 05-01 for parent linking pattern in generate-cascade
- Depends on 05-02 because manually created KPIs (from useCreateKpi) must also be preserved

Output: Modified generate-cascade with mode=incremental + useGenerateCascade hook
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-cascade-generation/05-01-SUMMARY.md (for parent linking pattern)
@.planning/phases/05-cascade-generation/05-02-SUMMARY.md (for manual KPI creation context)
@src/app/api/visions/[id]/generate-cascade/route.ts
@src/lib/hooks/query-keys.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add incremental mode to generate-cascade endpoint</name>
  <files>src/app/api/visions/[id]/generate-cascade/route.ts</files>
  <action>
Modify the generate-cascade endpoint to support incremental mode:

1. **Parse mode from request body:**
```typescript
const { quarters = [1, 2, 3, 4], goalsPerQuarter = 3, mode = 'full' } = body;
const isIncremental = mode === 'incremental';
```

2. **If incremental, load existing KPIs first:**
```typescript
let existingKpiTitles = new Set<string>();
if (isIncremental) {
  const { data: existingKpis } = await supabase
    .from('vision_kpis')
    .select('title, level')
    .eq('vision_id', visionId)
    .eq('user_id', userId);

  if (existingKpis) {
    existingKpiTitles = new Set(existingKpis.map(k => `${k.level}:${k.title.toLowerCase()}`));
  }
}
```

3. **Before each KPI insert, check if similar exists:**
```typescript
// Helper function to check if KPI already exists
function kpiExists(level: string, title: string): boolean {
  if (!isIncremental) return false;
  return existingKpiTitles.has(`${level}:${title.toLowerCase()}`);
}

// Example usage in quarterly KPI creation:
if (!kpiExists('quarterly', pg.quarterlyKpi.title)) {
  const { data: savedQuarterlyKpi, error: qkError } = await supabase
    .from('vision_kpis')
    .insert({ ... })
    .select('id')
    .single();
  // ... rest of creation logic
}
```

4. **Track what was created vs skipped:**
```typescript
const skippedStats = {
  quarterlyKpis: 0,
  monthlyKpis: 0,
  weeklyKpis: 0,
  dailyKpis: 0,
};
```

5. **Update response to include skipped counts:**
```typescript
return NextResponse.json({
  success: true,
  visionId,
  mode: isIncremental ? 'incremental' : 'full',
  summary: cascadeData.summary,
  // ... existing fields
  saved: savedStats,
  skipped: isIncremental ? skippedStats : undefined,
  message: isIncremental
    ? `Incremental update: Created ${totalNew} new items, skipped ${totalSkipped} existing`
    : `Created complete plan: ...`,
});
```

6. **Important: In incremental mode, still allow linking to existing parent KPIs:**
```typescript
// When we skip creating a quarterly KPI because it exists, we still need its ID for child linking
if (isIncremental && kpiExists('quarterly', pg.quarterlyKpi.title)) {
  // Look up existing KPI to get its ID
  const { data: existingQKpi } = await supabase
    .from('vision_kpis')
    .select('id')
    .eq('vision_id', visionId)
    .eq('level', 'quarterly')
    .ilike('title', pg.quarterlyKpi.title)
    .single();

  if (existingQKpi) {
    quarterlyKpiMap[pg.quarter] = existingQKpi.id;
  }
  skippedStats.quarterlyKpis++;
} else {
  // Create new quarterly KPI as before
}
```

**CAVEAT - Title Matching Fragility:**
The current implementation uses `.ilike('title', ...)` for matching existing KPIs. This is fragile because:
- If user edits a KPI title slightly (e.g., "Q1 Revenue" -> "Q1 Revenue Target"), it won't match
- This may cause duplicates on regeneration

**Recommendation for future improvement (Phase 7+):**
- Add a `source_hash` or `ai_generation_key` field to vision_kpis table
- Generate a deterministic hash from the AI prompt context
- Match on hash instead of title for robust deduplication

For now, title matching is acceptable because:
1. Most users won't edit AI-generated titles
2. Duplicates are visible and can be manually deleted
3. Better to have duplicates than lose user-customized KPIs
  </action>
  <verify>
1. Read modified route.ts
2. Confirm mode parameter is parsed from body
3. Confirm existing KPI check logic exists
4. Confirm skipped stats tracking exists
5. Confirm response includes mode and skipped counts
6. Run `npx tsc --noEmit`
  </verify>
  <done>
Generate-cascade endpoint supports incremental mode:
- mode='incremental' skips existing KPIs (by title match)
- Existing KPI IDs are looked up for child linking
- Response includes skipped counts
- Default mode='full' behaves as before
- Known limitation: title matching is fragile (documented for future improvement)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useGenerateCascade hook</name>
  <files>src/lib/hooks/use-cascade-generation.ts, src/lib/hooks/index.ts</files>
  <action>
Create a new hook file for cascade generation mutation.

**Create src/lib/hooks/use-cascade-generation.ts:**

```typescript
'use client';

/**
 * Cascade Generation Hook
 *
 * Mutation hook for triggering AI cascade generation from a vision.
 * Supports both full regeneration and incremental mode.
 */

import { useMutation, useQueryClient } from '@tanstack/react-query';
import { goalTreeKeys } from './query-keys';

export interface GenerateCascadeInput {
  visionId: string;
  quarters?: number[];
  goalsPerQuarter?: number;
  mode?: 'full' | 'incremental';
}

export interface GenerateCascadeResponse {
  success: boolean;
  visionId: string;
  mode: 'full' | 'incremental';
  summary: string;
  successFormula: string;
  totalEstimatedHours: number;
  saved: {
    impactProjects: number;
    monthlyTargets: number;
    weeklyTargets: number;
    dailyActions: number;
    quarterlyKpis: number;
    monthlyKpis: number;
    weeklyKpis: number;
    dailyKpis: number;
  };
  skipped?: {
    quarterlyKpis: number;
    monthlyKpis: number;
    weeklyKpis: number;
    dailyKpis: number;
  };
  message: string;
}

/**
 * Mutation hook for generating KPI cascade from a vision.
 *
 * @param visionId - The vision ID to generate cascade for
 * @returns Mutation object with mutate, isPending, error, etc.
 *
 * @example
 * ```tsx
 * const { mutate: generate, isPending } = useGenerateCascade(visionId);
 *
 * // Full regeneration (replaces existing - use carefully)
 * generate({ visionId, mode: 'full' });
 *
 * // Incremental (adds new, preserves existing)
 * generate({ visionId, mode: 'incremental' });
 * ```
 */
export function useGenerateCascade(visionId: string | undefined) {
  const queryClient = useQueryClient();

  return useMutation<GenerateCascadeResponse, Error, GenerateCascadeInput>({
    mutationFn: async (input: GenerateCascadeInput) => {
      const response = await fetch(`/api/visions/${input.visionId}/generate-cascade`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          quarters: input.quarters ?? [1, 2, 3, 4],
          goalsPerQuarter: input.goalsPerQuarter ?? 3,
          mode: input.mode ?? 'incremental', // Default to incremental for safety
        }),
      });

      if (!response.ok) {
        const data = await response.json().catch(() => ({}));
        throw new Error(data.error || 'Failed to generate cascade');
      }

      return response.json();
    },
    onSuccess: () => {
      // Invalidate goal tree to show new/updated KPIs
      if (visionId) {
        queryClient.invalidateQueries({ queryKey: goalTreeKeys.tree(visionId) });
      }
    },
  });
}
```

**Update src/lib/hooks/index.ts to export:**
```typescript
export {
  useGenerateCascade,
  type GenerateCascadeInput,
  type GenerateCascadeResponse,
} from './use-cascade-generation';
```
  </action>
  <verify>
1. File exists at src/lib/hooks/use-cascade-generation.ts
2. useGenerateCascade hook is defined with proper types
3. Default mode is 'incremental' for safety
4. Hook invalidates goal tree on success
5. Barrel export includes all exports
6. Run `npx tsc --noEmit`
  </verify>
  <done>
useGenerateCascade hook created:
- Supports full and incremental modes
- Defaults to incremental mode for safety
- Properly typed input and response
- Invalidates goal tree on success
- Exported from hooks barrel
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. Endpoint accepts mode parameter
3. Incremental mode skips existing KPIs
4. Hook defaults to incremental mode
5. Response includes skipped counts in incremental mode
</verification>

<success_criteria>
1. mode='incremental' parameter supported in generate-cascade
2. Incremental mode skips KPIs that already exist (by title)
3. Skipped KPI IDs are looked up for child linking
4. Response includes separate saved and skipped counts
5. useGenerateCascade hook defaults to incremental mode
6. Goal tree query is invalidated on success
7. TypeScript compiles without errors
8. Title matching fragility is documented as known limitation
</success_criteria>

<output>
After completion, create `.planning/phases/05-cascade-generation/05-03-SUMMARY.md`
</output>
