import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { getAuthenticatedUser } from '@/lib/auth/api-auth';

// Chart config type
interface ChartConfig {
  tagIds?: string[] | null; // null = all tags
  dateRangeOverride?: {
    start: string;
    end: string;
  } | null;
  aggregation?: 'daily' | 'weekly' | 'monthly';
  showLegend?: boolean;
  showValues?: boolean;
}

// GET: Fetch user's charts
export async function GET() {
  try {
    const auth = await getAuthenticatedUser();
    if (!auth.isAuthenticated) {
      return NextResponse.json({ error: auth.error }, { status: auth.status });
    }
    const userId = auth.userId;
    const supabase = await createClient();
    if (!supabase) {
      return NextResponse.json({ error: 'Database connection failed' }, { status: 500 });
    }

    const { data: charts, error } = await supabase
      .from('user_charts')
      .select('*')
      .eq('user_id', userId)
      .eq('is_visible', true)
      .order('position', { ascending: true });

    if (error) {
      console.error('Error fetching charts:', error);
      return NextResponse.json(
        { error: 'Failed to fetch charts' },
        { status: 500 }
      );
    }

    // Transform to camelCase
    const transformed = (charts || []).map(chart => ({
      id: chart.id,
      userId: chart.user_id,
      chartType: chart.chart_type,
      title: chart.title,
      config: chart.config as ChartConfig,
      position: chart.position,
      isAutoGenerated: chart.is_auto_generated,
      isVisible: chart.is_visible,
      createdAt: chart.created_at,
      updatedAt: chart.updated_at,
    }));

    return NextResponse.json({ charts: transformed });
  } catch (error) {
    console.error('Get charts error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch charts' },
      { status: 500 }
    );
  }
}

// POST: Create a new chart
export async function POST(request: NextRequest) {
  try {
    const auth = await getAuthenticatedUser();
    if (!auth.isAuthenticated) {
      return NextResponse.json({ error: auth.error }, { status: auth.status });
    }
    const userId = auth.userId;
    const supabase = await createClient();
    if (!supabase) {
      return NextResponse.json({ error: 'Database connection failed' }, { status: 500 });
    }

    const body = await request.json();

    const { chartType, title, config, isAutoGenerated } = body;

    if (!chartType || !['pie', 'bar', 'line'].includes(chartType)) {
      return NextResponse.json(
        { error: 'Valid chart type (pie, bar, line) is required' },
        { status: 400 }
      );
    }

    if (!title || !title.trim()) {
      return NextResponse.json(
        { error: 'Chart title is required' },
        { status: 400 }
      );
    }

    // Get the next position
    const { data: existingCharts } = await supabase
      .from('user_charts')
      .select('position')
      .eq('user_id', userId)
      .order('position', { ascending: false })
      .limit(1);

    const nextPosition = existingCharts && existingCharts.length > 0
      ? (existingCharts[0].position || 0) + 1
      : 0;

    const { data: chart, error } = await supabase
      .from('user_charts')
      .insert({
        user_id: userId,
        chart_type: chartType,
        title: title.trim(),
        config: config || {},
        position: nextPosition,
        is_auto_generated: isAutoGenerated || false,
      })
      .select()
      .single();

    if (error) {
      console.error('Error creating chart:', error);
      return NextResponse.json(
        { error: 'Failed to create chart' },
        { status: 500 }
      );
    }

    const transformed = {
      id: chart.id,
      userId: chart.user_id,
      chartType: chart.chart_type,
      title: chart.title,
      config: chart.config as ChartConfig,
      position: chart.position,
      isAutoGenerated: chart.is_auto_generated,
      isVisible: chart.is_visible,
      createdAt: chart.created_at,
      updatedAt: chart.updated_at,
    };

    return NextResponse.json({ chart: transformed });
  } catch (error) {
    console.error('Create chart error:', error);
    return NextResponse.json(
      { error: 'Failed to create chart' },
      { status: 500 }
    );
  }
}

// PUT: Update an existing chart
export async function PUT(request: NextRequest) {
  try {
    const auth = await getAuthenticatedUser();
    if (!auth.isAuthenticated) {
      return NextResponse.json({ error: auth.error }, { status: auth.status });
    }
    const userId = auth.userId;
    const supabase = await createClient();
    if (!supabase) {
      return NextResponse.json({ error: 'Database connection failed' }, { status: 500 });
    }

    const body = await request.json();

    const { id, chartType, title, config, position, isVisible } = body;

    if (!id) {
      return NextResponse.json(
        { error: 'Chart ID is required' },
        { status: 400 }
      );
    }

    const updateData: Record<string, unknown> = {
      updated_at: new Date().toISOString(),
    };

    if (chartType !== undefined) {
      if (!['pie', 'bar', 'line'].includes(chartType)) {
        return NextResponse.json(
          { error: 'Valid chart type (pie, bar, line) is required' },
          { status: 400 }
        );
      }
      updateData.chart_type = chartType;
    }
    if (title !== undefined) updateData.title = title.trim();
    if (config !== undefined) updateData.config = config;
    if (position !== undefined) updateData.position = position;
    if (isVisible !== undefined) updateData.is_visible = isVisible;

    const { data: chart, error } = await supabase
      .from('user_charts')
      .update(updateData)
      .eq('id', id)
      .eq('user_id', userId)
      .select()
      .single();

    if (error) {
      console.error('Error updating chart:', error);
      return NextResponse.json(
        { error: 'Failed to update chart' },
        { status: 500 }
      );
    }

    const transformed = {
      id: chart.id,
      userId: chart.user_id,
      chartType: chart.chart_type,
      title: chart.title,
      config: chart.config as ChartConfig,
      position: chart.position,
      isAutoGenerated: chart.is_auto_generated,
      isVisible: chart.is_visible,
      createdAt: chart.created_at,
      updatedAt: chart.updated_at,
    };

    return NextResponse.json({ chart: transformed });
  } catch (error) {
    console.error('Update chart error:', error);
    return NextResponse.json(
      { error: 'Failed to update chart' },
      { status: 500 }
    );
  }
}

// DELETE: Delete a chart (hard delete)
export async function DELETE(request: NextRequest) {
  try {
    const auth = await getAuthenticatedUser();
    if (!auth.isAuthenticated) {
      return NextResponse.json({ error: auth.error }, { status: auth.status });
    }
    const userId = auth.userId;
    const supabase = await createClient();
    if (!supabase) {
      return NextResponse.json({ error: 'Database connection failed' }, { status: 500 });
    }

    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');

    if (!id) {
      return NextResponse.json(
        { error: 'Chart ID is required' },
        { status: 400 }
      );
    }

    const { error } = await supabase
      .from('user_charts')
      .delete()
      .eq('id', id)
      .eq('user_id', userId);

    if (error) {
      console.error('Error deleting chart:', error);
      return NextResponse.json(
        { error: 'Failed to delete chart' },
        { status: 500 }
      );
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Delete chart error:', error);
    return NextResponse.json(
      { error: 'Failed to delete chart' },
      { status: 500 }
    );
  }
}
