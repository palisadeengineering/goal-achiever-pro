'use client';

import { useState, useEffect, useCallback } from 'react';
import { format, subDays, startOfWeek, endOfWeek } from 'date-fns';
import { Plus, Settings, Trash2, BarChart3, PieChart, TrendingUp, Tag } from 'lucide-react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Checkbox } from '@/components/ui/checkbox';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog';
import { PieChart as RechartsPie, Pie, Cell, ResponsiveContainer, Legend, Tooltip, BarChart, Bar, XAxis, YAxis, CartesianGrid, LineChart, Line } from 'recharts';

// Types
interface TagInfo {
  id: string;
  name: string;
  color: string;
}

interface ChartConfig {
  tagIds?: string[] | null;
  dateRangeOverride?: {
    start: string;
    end: string;
  } | null;
  aggregation?: 'daily' | 'weekly' | 'monthly';
  showLegend?: boolean;
  showValues?: boolean;
}

interface UserChart {
  id: string;
  userId: string;
  chartType: 'pie' | 'bar' | 'line';
  title: string;
  config: ChartConfig;
  position: number;
  isAutoGenerated: boolean;
  isVisible: boolean;
  createdAt: string;
  updatedAt: string;
}

interface DistributionDataItem {
  tagId: string;
  tagName: string;
  tagColor: string;
  totalMinutes: number;
  percentage: number;
  hours: number;
}

interface TrendDataItem {
  date: string;
  tagData: Array<{
    tagId: string;
    tagName: string;
    tagColor: string;
    minutes: number;
  }>;
}

interface ChartDataResponse {
  distribution: DistributionDataItem[];
  trend: TrendDataItem[];
  summary: {
    totalMinutes: number;
    totalHours: number;
    tagCount: number;
    dateRange: { startDate: string; endDate: string };
  };
}

interface ChartsViewProps {
  dateRange: { start: Date; end: Date };
  availableTags: TagInfo[];
  onManageTags: () => void;
}

// Chart Card Component
function ChartCard({
  chart,
  dateRange,
  onEdit,
  onDelete,
}: {
  chart: UserChart;
  dateRange: { start: Date; end: Date };
  onEdit: (chart: UserChart) => void;
  onDelete: (chart: UserChart) => void;
}) {
  const [data, setData] = useState<ChartDataResponse | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  // Determine effective date range (chart override or page default)
  const effectiveDateRange = chart.config.dateRangeOverride
    ? { start: new Date(chart.config.dateRangeOverride.start), end: new Date(chart.config.dateRangeOverride.end) }
    : dateRange;

  useEffect(() => {
    const fetchData = async () => {
      setIsLoading(true);
      try {
        const params = new URLSearchParams({
          startDate: format(effectiveDateRange.start, 'yyyy-MM-dd'),
          endDate: format(effectiveDateRange.end, 'yyyy-MM-dd'),
          aggregation: chart.config.aggregation || 'daily',
        });

        if (chart.config.tagIds && chart.config.tagIds.length > 0) {
          params.set('tagIds', chart.config.tagIds.join(','));
        }

        const response = await fetch(`/api/user-charts/data?${params}`);
        if (response.ok) {
          const result = await response.json();
          setData(result);
        }
      } catch (error) {
        console.error('Failed to fetch chart data:', error);
      } finally {
        setIsLoading(false);
      }
    };

    fetchData();
  }, [effectiveDateRange.start, effectiveDateRange.end, chart.config.tagIds, chart.config.aggregation]);

  const renderChart = () => {
    if (isLoading) {
      return (
        <div className="h-[250px] flex items-center justify-center text-muted-foreground">
          Loading...
        </div>
      );
    }

    if (!data || data.distribution.length === 0) {
      return (
        <div className="h-[250px] flex flex-col items-center justify-center text-muted-foreground gap-2">
          <Tag className="h-8 w-8 opacity-50" />
          <p className="text-sm">No tagged data available</p>
          <p className="text-xs">Tag some time blocks to see analytics</p>
        </div>
      );
    }

    // Prepare data for charts
    const pieData = data.distribution.map(d => ({
      name: d.tagName,
      value: d.hours,
      color: d.tagColor,
      percentage: d.percentage,
    }));

    const barData = data.distribution.map(d => ({
      name: d.tagName,
      hours: parseFloat(d.hours.toFixed(1)),
      fill: d.tagColor,
    }));

    // For line chart, transform trend data
    const lineData = data.trend.map(t => {
      const entry: Record<string, string | number> = { date: format(new Date(t.date), 'MMM d') };
      t.tagData.forEach(td => {
        entry[td.tagName] = parseFloat((td.minutes / 60).toFixed(1));
      });
      return entry;
    });

    switch (chart.chartType) {
      case 'pie':
        return (
          <ResponsiveContainer width="100%" height={250}>
            <RechartsPie>
              <Pie
                data={pieData}
                dataKey="value"
                nameKey="name"
                cx="50%"
                cy="50%"
                outerRadius={80}
                label={chart.config.showValues ? ({ name, percent }: { name?: string; percent?: number }) =>
                  `${name || ''} (${((percent || 0) * 100).toFixed(0)}%)` : false}
                labelLine={chart.config.showValues}
              >
                {pieData.map((entry, index) => (
                  <Cell key={`cell-${index}`} fill={entry.color} />
                ))}
              </Pie>
              {chart.config.showLegend !== false && <Legend />}
              <Tooltip formatter={(value) => `${Number(value).toFixed(1)} hrs`} />
            </RechartsPie>
          </ResponsiveContainer>
        );

      case 'bar':
        return (
          <ResponsiveContainer width="100%" height={250}>
            <BarChart data={barData} layout="vertical" margin={{ left: 80 }}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis type="number" unit=" hrs" />
              <YAxis type="category" dataKey="name" width={75} tick={{ fontSize: 12 }} />
              <Tooltip formatter={(value) => `${Number(value)} hrs`} />
              <Bar dataKey="hours" radius={[0, 4, 4, 0]}>
                {barData.map((entry, index) => (
                  <Cell key={`cell-${index}`} fill={entry.fill} />
                ))}
              </Bar>
            </BarChart>
          </ResponsiveContainer>
        );

      case 'line':
        const uniqueTags = data.distribution.map(d => ({ name: d.tagName, color: d.tagColor }));
        return (
          <ResponsiveContainer width="100%" height={250}>
            <LineChart data={lineData} margin={{ left: 0, right: 20 }}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="date" tick={{ fontSize: 11 }} />
              <YAxis unit=" hrs" tick={{ fontSize: 11 }} />
              <Tooltip formatter={(value) => `${Number(value)} hrs`} />
              {chart.config.showLegend !== false && <Legend />}
              {uniqueTags.map(tag => (
                <Line
                  key={tag.name}
                  type="monotone"
                  dataKey={tag.name}
                  stroke={tag.color}
                  strokeWidth={2}
                  dot={{ r: 3 }}
                  activeDot={{ r: 5 }}
                />
              ))}
            </LineChart>
          </ResponsiveContainer>
        );

      default:
        return null;
    }
  };

  const getChartIcon = () => {
    switch (chart.chartType) {
      case 'pie': return <PieChart className="h-4 w-4" />;
      case 'bar': return <BarChart3 className="h-4 w-4" />;
      case 'line': return <TrendingUp className="h-4 w-4" />;
    }
  };

  return (
    <Card className="overflow-hidden">
      <CardHeader className="pb-2">
        <div className="flex items-center justify-between">
          <CardTitle className="text-base flex items-center gap-2">
            {getChartIcon()}
            {chart.title}
            {chart.isAutoGenerated && (
              <Badge variant="secondary" className="text-[10px] font-normal">Auto</Badge>
            )}
          </CardTitle>
          <div className="flex items-center gap-1">
            <Button variant="ghost" size="icon" className="h-7 w-7" onClick={() => onEdit(chart)}>
              <Settings className="h-3.5 w-3.5" />
            </Button>
            <Button variant="ghost" size="icon" className="h-7 w-7 text-destructive hover:text-destructive" onClick={() => onDelete(chart)}>
              <Trash2 className="h-3.5 w-3.5" />
            </Button>
          </div>
        </div>
        {data && (
          <p className="text-xs text-muted-foreground">
            {data.summary.totalHours.toFixed(1)} total hours from {data.summary.tagCount} tags
          </p>
        )}
      </CardHeader>
      <CardContent className="pt-0">
        {renderChart()}
      </CardContent>
    </Card>
  );
}

// Main Charts View Component
export function ChartsView({ dateRange, availableTags, onManageTags }: ChartsViewProps) {
  const [charts, setCharts] = useState<UserChart[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [showAddDialog, setShowAddDialog] = useState(false);
  const [editingChart, setEditingChart] = useState<UserChart | null>(null);
  const [deleteConfirm, setDeleteConfirm] = useState<UserChart | null>(null);

  // Form state
  const [formTitle, setFormTitle] = useState('');
  const [formChartType, setFormChartType] = useState<'pie' | 'bar' | 'line'>('pie');
  const [formSelectedTags, setFormSelectedTags] = useState<string[]>([]);
  const [formAggregation, setFormAggregation] = useState<'daily' | 'weekly' | 'monthly'>('daily');
  const [formShowLegend, setFormShowLegend] = useState(true);
  const [formShowValues, setFormShowValues] = useState(true);
  const [isSaving, setIsSaving] = useState(false);

  // Generate default charts if none exist
  const generateDefaultCharts = useCallback(async () => {
    const defaultCharts = [
      {
        title: 'Time Distribution',
        chartType: 'pie' as const,
        config: { showLegend: true, showValues: true },
      },
      {
        title: 'Hours by Category',
        chartType: 'bar' as const,
        config: { showLegend: false },
      },
      {
        title: 'Weekly Trend',
        chartType: 'line' as const,
        config: { aggregation: 'daily' as const, showLegend: true },
      },
    ];

    const createdCharts: UserChart[] = [];
    for (const chartDef of defaultCharts) {
      try {
        const response = await fetch('/api/user-charts', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            ...chartDef,
            isAutoGenerated: true,
          }),
        });
        if (response.ok) {
          const data = await response.json();
          if (data.chart) {
            createdCharts.push(data.chart);
          }
        }
      } catch (error) {
        console.error('Failed to create default chart:', error);
      }
    }
    return createdCharts;
  }, []);

  // Fetch charts
  const fetchCharts = useCallback(async () => {
    setIsLoading(true);
    try {
      const response = await fetch('/api/user-charts');
      if (response.ok) {
        const data = await response.json();
        let fetchedCharts = data.charts || [];

        // If no charts exist but we have tags, generate defaults
        if (fetchedCharts.length === 0 && availableTags.length > 0) {
          const defaultCharts = await generateDefaultCharts();
          fetchedCharts = defaultCharts;
        }

        setCharts(fetchedCharts);
      }
    } catch (error) {
      console.error('Failed to fetch charts:', error);
    } finally {
      setIsLoading(false);
    }
  }, [availableTags.length, generateDefaultCharts]);

  useEffect(() => {
    fetchCharts();
  }, [fetchCharts]);

  // Reset form
  const resetForm = () => {
    setFormTitle('');
    setFormChartType('pie');
    setFormSelectedTags([]);
    setFormAggregation('daily');
    setFormShowLegend(true);
    setFormShowValues(true);
    setEditingChart(null);
  };

  // Open add dialog
  const handleOpenAddDialog = () => {
    resetForm();
    setShowAddDialog(true);
  };

  // Open edit dialog
  const handleEdit = (chart: UserChart) => {
    setFormTitle(chart.title);
    setFormChartType(chart.chartType);
    setFormSelectedTags(chart.config.tagIds || []);
    setFormAggregation(chart.config.aggregation || 'daily');
    setFormShowLegend(chart.config.showLegend !== false);
    setFormShowValues(chart.config.showValues !== false);
    setEditingChart(chart);
    setShowAddDialog(true);
  };

  // Save chart (create or update)
  const handleSave = async () => {
    if (!formTitle.trim()) return;

    setIsSaving(true);
    try {
      const config: ChartConfig = {
        tagIds: formSelectedTags.length > 0 ? formSelectedTags : null,
        aggregation: formAggregation,
        showLegend: formShowLegend,
        showValues: formShowValues,
      };

      if (editingChart) {
        // Update
        const response = await fetch('/api/user-charts', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            id: editingChart.id,
            title: formTitle.trim(),
            chartType: formChartType,
            config,
          }),
        });

        if (response.ok) {
          await fetchCharts();
          setShowAddDialog(false);
          resetForm();
        }
      } else {
        // Create
        const response = await fetch('/api/user-charts', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            title: formTitle.trim(),
            chartType: formChartType,
            config,
          }),
        });

        if (response.ok) {
          await fetchCharts();
          setShowAddDialog(false);
          resetForm();
        }
      }
    } catch (error) {
      console.error('Failed to save chart:', error);
    } finally {
      setIsSaving(false);
    }
  };

  // Delete chart
  const handleDelete = async (chart: UserChart) => {
    try {
      const response = await fetch(`/api/user-charts?id=${chart.id}`, {
        method: 'DELETE',
      });

      if (response.ok) {
        await fetchCharts();
      }
    } catch (error) {
      console.error('Failed to delete chart:', error);
    } finally {
      setDeleteConfirm(null);
    }
  };

  // Toggle tag selection
  const toggleTagSelection = (tagId: string) => {
    setFormSelectedTags(prev =>
      prev.includes(tagId)
        ? prev.filter(id => id !== tagId)
        : [...prev, tagId]
    );
  };

  if (isLoading) {
    return (
      <Card>
        <CardContent className="py-12">
          <div className="flex flex-col items-center justify-center text-muted-foreground gap-2">
            <div className="animate-spin h-8 w-8 border-2 border-primary border-t-transparent rounded-full" />
            <p className="text-sm">Loading charts...</p>
          </div>
        </CardContent>
      </Card>
    );
  }

  // Empty state
  if (charts.length === 0 && availableTags.length === 0) {
    return (
      <Card>
        <CardContent className="py-12">
          <div className="flex flex-col items-center justify-center text-center gap-4">
            <div className="h-16 w-16 rounded-full bg-muted flex items-center justify-center">
              <BarChart3 className="h-8 w-8 text-muted-foreground" />
            </div>
            <div>
              <h3 className="font-semibold text-lg">No charts yet</h3>
              <p className="text-muted-foreground text-sm mt-1">
                Add tags to your time blocks to see analytics here.
              </p>
            </div>
            <div className="flex gap-2">
              <Button variant="outline" onClick={onManageTags}>
                <Tag className="h-4 w-4 mr-2" />
                Create Tags
              </Button>
            </div>
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <div className="space-y-4">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <p className="text-sm text-muted-foreground">
            {format(dateRange.start, 'MMM d')} - {format(dateRange.end, 'MMM d, yyyy')}
          </p>
        </div>
        <div className="flex items-center gap-2">
          <Button variant="outline" size="sm" onClick={onManageTags}>
            <Tag className="h-4 w-4 mr-2" />
            Manage Tags
          </Button>
          <Button size="sm" onClick={handleOpenAddDialog}>
            <Plus className="h-4 w-4 mr-2" />
            Add Chart
          </Button>
        </div>
      </div>

      {/* Charts Grid */}
      {charts.length === 0 ? (
        <Card>
          <CardContent className="py-12">
            <div className="flex flex-col items-center justify-center text-center gap-4">
              <div className="h-16 w-16 rounded-full bg-muted flex items-center justify-center">
                <BarChart3 className="h-8 w-8 text-muted-foreground" />
              </div>
              <div>
                <h3 className="font-semibold text-lg">No charts yet</h3>
                <p className="text-muted-foreground text-sm mt-1">
                  Create your first chart to visualize your time data.
                </p>
              </div>
              <Button onClick={handleOpenAddDialog}>
                <Plus className="h-4 w-4 mr-2" />
                Create Chart
              </Button>
            </div>
          </CardContent>
        </Card>
      ) : (
        <div className="grid gap-4 md:grid-cols-2">
          {charts.map(chart => (
            <ChartCard
              key={chart.id}
              chart={chart}
              dateRange={dateRange}
              onEdit={handleEdit}
              onDelete={setDeleteConfirm}
            />
          ))}
        </div>
      )}

      {/* Add/Edit Chart Dialog */}
      <Dialog open={showAddDialog} onOpenChange={(open) => {
        if (!open) resetForm();
        setShowAddDialog(open);
      }}>
        <DialogContent className="max-w-md">
          <DialogHeader>
            <DialogTitle>{editingChart ? 'Edit Chart' : 'Add New Chart'}</DialogTitle>
            <DialogDescription>
              Configure your chart settings
            </DialogDescription>
          </DialogHeader>

          <div className="space-y-4">
            {/* Title */}
            <div className="space-y-2">
              <Label htmlFor="chart-title">Chart Title</Label>
              <Input
                id="chart-title"
                value={formTitle}
                onChange={(e) => setFormTitle(e.target.value)}
                placeholder="e.g., Time Distribution"
              />
            </div>

            {/* Chart Type */}
            <div className="space-y-2">
              <Label>Chart Type</Label>
              <div className="grid grid-cols-3 gap-2">
                <Button
                  type="button"
                  variant={formChartType === 'pie' ? 'default' : 'outline'}
                  className="flex flex-col gap-1 h-auto py-3"
                  onClick={() => setFormChartType('pie')}
                >
                  <PieChart className="h-5 w-5" />
                  <span className="text-xs">Pie</span>
                </Button>
                <Button
                  type="button"
                  variant={formChartType === 'bar' ? 'default' : 'outline'}
                  className="flex flex-col gap-1 h-auto py-3"
                  onClick={() => setFormChartType('bar')}
                >
                  <BarChart3 className="h-5 w-5" />
                  <span className="text-xs">Bar</span>
                </Button>
                <Button
                  type="button"
                  variant={formChartType === 'line' ? 'default' : 'outline'}
                  className="flex flex-col gap-1 h-auto py-3"
                  onClick={() => setFormChartType('line')}
                >
                  <TrendingUp className="h-5 w-5" />
                  <span className="text-xs">Line</span>
                </Button>
              </div>
            </div>

            {/* Tags Selection */}
            <div className="space-y-2">
              <Label>Tags (leave empty for all)</Label>
              <div className="border rounded-md p-3 max-h-32 overflow-y-auto space-y-2">
                {availableTags.length === 0 ? (
                  <p className="text-sm text-muted-foreground">No tags available</p>
                ) : (
                  availableTags.map(tag => (
                    <div key={tag.id} className="flex items-center gap-2">
                      <Checkbox
                        id={`tag-${tag.id}`}
                        checked={formSelectedTags.includes(tag.id)}
                        onCheckedChange={() => toggleTagSelection(tag.id)}
                      />
                      <label
                        htmlFor={`tag-${tag.id}`}
                        className="flex items-center gap-2 text-sm cursor-pointer"
                      >
                        <span
                          className="h-3 w-3 rounded-full"
                          style={{ backgroundColor: tag.color }}
                        />
                        {tag.name}
                      </label>
                    </div>
                  ))
                )}
              </div>
            </div>

            {/* Aggregation (for line charts) */}
            {formChartType === 'line' && (
              <div className="space-y-2">
                <Label>Aggregation</Label>
                <Select value={formAggregation} onValueChange={(v) => setFormAggregation(v as 'daily' | 'weekly' | 'monthly')}>
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="daily">Daily</SelectItem>
                    <SelectItem value="weekly">Weekly</SelectItem>
                    <SelectItem value="monthly">Monthly</SelectItem>
                  </SelectContent>
                </Select>
              </div>
            )}

            {/* Options */}
            <div className="space-y-3">
              <div className="flex items-center gap-2">
                <Checkbox
                  id="show-legend"
                  checked={formShowLegend}
                  onCheckedChange={(checked) => setFormShowLegend(checked === true)}
                />
                <label htmlFor="show-legend" className="text-sm cursor-pointer">
                  Show legend
                </label>
              </div>
              {formChartType === 'pie' && (
                <div className="flex items-center gap-2">
                  <Checkbox
                    id="show-values"
                    checked={formShowValues}
                    onCheckedChange={(checked) => setFormShowValues(checked === true)}
                  />
                  <label htmlFor="show-values" className="text-sm cursor-pointer">
                    Show values on chart
                  </label>
                </div>
              )}
            </div>
          </div>

          <DialogFooter>
            <Button variant="outline" onClick={() => setShowAddDialog(false)}>
              Cancel
            </Button>
            <Button onClick={handleSave} disabled={!formTitle.trim() || isSaving}>
              {isSaving ? 'Saving...' : editingChart ? 'Save Changes' : 'Create Chart'}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Delete Confirmation */}
      <AlertDialog open={!!deleteConfirm} onOpenChange={(open) => !open && setDeleteConfirm(null)}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Delete Chart</AlertDialogTitle>
            <AlertDialogDescription>
              Are you sure you want to delete &quot;{deleteConfirm?.title}&quot;? This action cannot be undone.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
              onClick={() => deleteConfirm && handleDelete(deleteConfirm)}
            >
              Delete
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}
